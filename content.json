{"meta":{"title":"俩天的博客","subtitle":"日常记录","description":"person blog","author":"xuegangliu","url":"https://github.com/xuegangliu/blog"},"pages":[{"title":"关于我","date":"2016-11-08T17:39:07.000Z","updated":"2018-01-09T14:08:37.000Z","comments":true,"path":"about.html","permalink":"https://github.com/xuegangliu/blog/about.html","excerpt":"","text":"刘雪岗 内蒙古师范大学 计算机科学与技术 本科 联系方式 手机：176-0088-5165 Email：lxghoney@163.com QQ/微信号：1453860636 工作经历 亚信中国 2017.07-至今CUC部门铁塔支持部 中交兴路 2016.08-2017.05油品事业部 亚信中国 （ 2017年07月 ~ 至今 ）铁塔CRM我在此项目负责铁塔变更、追溯业务开发，每周任务上线、问题处理。在项目中负责整个CRM后台项目的上线实施操作，上线问题处理。面对线上问题，对于线上环境出现的问题，利用JVM虚拟机命令查询出线程执行情况，并快速解决问题。 中交兴路 （ 2016年08月 ~ 2017年05月 ）elap日志分析平台项目介绍：对日志进行收集(主要通过syslog、nxlog)、分析、字段提取。对日志进行日志流分类，日志警告通知、日志仪表盘的展示，以及一些系统配置，日志地图统计。工作任务：搭建服务器环境，在服务器设置日志输入端口，在客户端将日志发送到服务端，存储到elasticsearch中，进行聚合统计出图。利用自定义语句根据antlr语法分析，统计最终的数据从而用echarts进行出图展示。日志模式进行日志消息相似度计算得出统计数据。项目使用技术：Guice+guava+react+antlr+echart数据库：mongo搜索引擎及存储：Elasticsearch 柴油联名卡项目介绍：中石化与中交兴路推出柴油专用联名卡。联名卡由个人用户企业用户进行申请，进行对油卡的申请、充值、授信、返利、开票等。工作任务：负责联名卡企业办卡申请模块的开发，与前端人员进行接口联调。负责油卡后台管理油卡审核模块、油卡管理、会员管理，以及提供给金融组所需要的接口。完成项目一期开发，使项目成功上线。项目使用技术：Spring+SpringMVC+Mybatis+Vue服务间调用：dubbo、hession数据库：mysql(docker)、redis 蓝海保险系统项目介绍：国家电网英大传媒内部人员查阅电力案例的文档信息，它包含案例展示、会员中心、案例搜索、上传案例、收藏案例、打印案例、会员登陆、后台网站资源管理、后台统 计分析、后台积分管理、后台语义词表、后台资源加工、后台资源 管理、后台授权管理等。工作任务：分析讨论业务需求，编写数据说明书，数据字典。负责电力案例分类模块研发，案例库关键词搜索、网站资源等模块的研发。 项目技术：Spring+SpringMVC+JPA+shiro+ueditor+angular+avalon 数据库：mysql 服务器：tomcat 开源项目和作品个人作品 开源项目 ACM：ACM评测系统 graylog2：日志分析系统 致谢感谢您花时间阅读我的简历，期待能有机会和您共事。"},{"title":"友情链接","date":"2016-11-08T17:39:07.000Z","updated":"2019-01-09T14:08:37.000Z","comments":true,"path":"links.html","permalink":"https://github.com/xuegangliu/blog/links.html","excerpt":"","text":"友情链接blog大牛 翟永超 阮一峰 不会就问咯 java1234-小锋 数据结构与算法 skywang12345 其它 洪海亮 我全科 数据库 寒夕若梦"},{"title":"categories","date":"2016-03-02T12:33:16.000Z","updated":"2019-01-08T09:33:17.930Z","comments":false,"path":"categories/index.html","permalink":"https://github.com/xuegangliu/blog/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"travis配置","slug":"travis构建","date":"2019-01-08T16:52:37.000Z","updated":"2019-01-08T16:52:37.000Z","comments":true,"path":"2019/01/08/travis构建/","link":"","permalink":"https://github.com/xuegangliu/blog/2019/01/08/travis构建/","excerpt":"","text":"travis构建github代码库中的项目 配置travis.yml 1234567891011121314151617181920212223242526272829303132333435# 选择项目的语言及版本language: pythonpython: - &quot;2.7&quot;# 打包之前的操作before_install: &quot;sudo apt-get update&quot;# 依赖安装等install: &quot;pip install -q -r requirements.txt --use-mirrors&quot;# 构建script: make html# 限制项目分支branches: only: - mybranch## 构建完成之后的命令after_success: &quot;find ./make/output -type f -exec curl --ftp-create-dirs -u $FTP_USER:$FTP_PASSWORD -T &#123;&#125; ftp://123.45.67.89/myproject/&#123;&#125; \\\\;&quot;#环境变量env: global: - &quot;FTP_USER=myusername&quot; - &quot;FTP_PASSWORD=mypassword&quot;# 邮件通知notifications: email: recipients: - 1453860636@qq.com on_success: change on_failure: always","categories":[{"name":"Travis","slug":"Travis","permalink":"https://github.com/xuegangliu/blog/categories/Travis/"}],"tags":[{"name":"build","slug":"build","permalink":"https://github.com/xuegangliu/blog/tags/build/"},{"name":"Travis","slug":"Travis","permalink":"https://github.com/xuegangliu/blog/tags/Travis/"}]},{"title":"Ubuntu结构","slug":"Ubuntu结构","date":"2018-11-09T15:28:01.000Z","updated":"2018-11-09T15:28:01.000Z","comments":true,"path":"2018/11/09/Ubuntu结构/","link":"","permalink":"https://github.com/xuegangliu/blog/2018/11/09/Ubuntu结构/","excerpt":"","text":"目录结构 软件包管理Ubuntu更新软件时的软件源配置文件是/etc/apt/sources.list。ubuntu的官方软件源分为4类： main：这个是官方维护的基本库。 restricted：官方维护的其他自由软件。 universe：自由软件，但是官方不维护。 multiverse：非自由软件，官方不维护。 aptapt是一套完整的软件包管理方案。除了最常用apt-get之外，还包括了一系列的客户端和服务器软件。例如：12sudo apt-cache search gstreamer 搜索名字中包含gstreamer的软件包。sudo add-apt-repository ppa:tualatrix/ppa添加新的软件源。 安装命令123sudo apt-get install foodpkg -i *.debwget http://* 卸载命令12sudo apt-get --purge remove foosudo apt-get remove foo","categories":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/xuegangliu/blog/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/xuegangliu/blog/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://github.com/xuegangliu/blog/tags/Ubuntu/"}]},{"title":"JVM性能调优","slug":"JVM性能调优","date":"2018-11-09T15:19:01.000Z","updated":"2018-11-09T15:19:01.000Z","comments":true,"path":"2018/11/09/JVM性能调优/","link":"","permalink":"https://github.com/xuegangliu/blog/2018/11/09/JVM性能调优/","excerpt":"","text":"JVM性能调优一、JVM内存模型及垃圾收集算法1.根据Java虚拟机规范，JVM将内存划分为： New（年轻代)[启动分配堆内存]（-Xmx:3G） 年轻代用来存放JVM刚分配的Java对象 Eden：Eden用来存放JVM刚分配的对象 Survivor1 Survivro2：两个Survivor空间一样大，当Eden中的对象经过垃圾回收没有被回收掉时，会在两个Survivor之间来回Copy，当满足某个条件，比如Copy次数，就会被Copy到Tenured。显然，Survivor只是增加了对象在年轻代中的逗留时间，增加了被垃圾回收的可能性。 Tenured（年老代）[启动分配堆内存]（-Xmx:3G） 永久代（Perm）[JVM分配内存] （-XX:PermSize -XX:MaxPermSize） 2.垃圾回收算法垃圾回收算法可以分为三类，都基于标记-清除（复制）算法： Serial算法（单线程） 并行算法 并发算法 链接JVM性能调优","categories":[{"name":"Java","slug":"Java","permalink":"https://github.com/xuegangliu/blog/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://github.com/xuegangliu/blog/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"https://github.com/xuegangliu/blog/tags/JVM/"}]},{"title":"JVM命令工具","slug":"JVM命令工具","date":"2018-02-09T15:14:30.000Z","updated":"2018-03-02T11:25:33.000Z","comments":true,"path":"2018/02/09/JVM命令工具/","link":"","permalink":"https://github.com/xuegangliu/blog/2018/02/09/JVM命令工具/","excerpt":"","text":"命令工具 jps：进程列表 jinfo：进程配置信息 jstat：内存配置信息 jstack：堆栈信息 jmap：dump堆内存快照 jhat：和jmap配合使用，分析堆内存快照文件 jps-q 只输出LVMID，同进程pid -m 输出JVM启动时传给主类main()的参数。 -l 输出主类全名。如果进程执行的是jar包，则输出包名。 -v 输出JVM启动时JVM参数。 jinfo-flag name 打印给定name对应的命令行参数值。 -flag [+|-]name 更改boolean类型的命令行参数值 -flag name=value 更改name对应的命令行参数值为value。 -flags 打印传给JVM的命令参数值。 -sysprops 打印系统属性值。 链接介绍","categories":[{"name":"Java","slug":"Java","permalink":"https://github.com/xuegangliu/blog/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://github.com/xuegangliu/blog/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"https://github.com/xuegangliu/blog/tags/JVM/"}]},{"title":"Tomcat调优","slug":"Tomcat调优","date":"2018-01-09T15:16:45.000Z","updated":"2018-01-09T15:16:45.000Z","comments":true,"path":"2018/01/09/Tomcat调优/","link":"","permalink":"https://github.com/xuegangliu/blog/2018/01/09/Tomcat调优/","excerpt":"","text":"1.tomcat内存配置 案例：由于服务启动后，会有大量的excel文件进行生成，以及大量的定时任务在跑。导致服务抛出堆溢出。 解决办法：设置服务JVM参数 JAVA_OPTS=’-Xms【初始化内存大小】 -Xmx【可以使用的最大内存】’最大值设置为可用内存的最大值的80% 2.tomcat线程优化1、JDK内存优化2、连接器优化`maxThreads`： Tomcat使用线程来处理接收的每个请求。这个值表示Tomcat可创建的最大的线程数。默认值150。 `acceptCount`： 指定当所有可以使用的处理请求的线程数都被使用时，可以放到处理队列中的请求数，超过这个数的请求将不予处理。默认值10。 `minSpareThreads`： Tomcat初始化时创建的线程数。默认值25。 `maxSpareThreads`： 一旦创建的线程超过这个值，Tomcat就会关闭不再需要的socket线程。默认值75。 `enableLookups`： 是否反查域名，默认值为true。为了提高处理能力，应设置为false connnectionTimeout： 网络连接超时，默认值60000，单位：毫秒。设置为0表示永不超时，这样设置有隐患的。通常可设置为30000毫秒。 `maxKeepAliveRequests`： 保持请求数量，默认值100。 `bufferSize`： 输入流缓冲大小，默认值2048 bytes。 `compression`： 压缩传输，取值on/off/force，默认值off。 其中和最大连接数相关的参数为maxThreads和acceptCount。如果要加大并发连接数，应同时加大这两个参数。web server允许的最大连接数还受制于*作系统的内核参数设置，通常Windows是2000个左右，Linux是1000个左右。 3.tomcat中如何禁止和允许列目录下的文件4.tomcat中如何禁止和允许主机或IP地址访问","categories":[{"name":"Tomcat","slug":"Tomcat","permalink":"https://github.com/xuegangliu/blog/categories/Tomcat/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://github.com/xuegangliu/blog/tags/Java/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://github.com/xuegangliu/blog/tags/Tomcat/"}]},{"title":"JVM参数","slug":"JVM参数","date":"2018-01-09T10:13:23.000Z","updated":"2018-01-09T10:13:23.000Z","comments":true,"path":"2018/01/09/JVM参数/","link":"","permalink":"https://github.com/xuegangliu/blog/2018/01/09/JVM参数/","excerpt":"","text":"jvm参数JVM 类型以及编译器模式 类型：-server and -client 版本信息：-version and -showversion 编译器模式：-Xint（解释模式 执行所有【慢】）, -Xcomp（JIT 编译器少部分功能）, 和 - Xmixed（混合模式） 参数分类和即时（JIT）编译器诊断 标准参数 X参数 XX参数 -XX:+PrintCompilation 输出一些关于从字节码转化成本地代码的编译过程 -XX:+CITime JVM 关闭时得到各种编译的统计信息 -XX:+PrintFlagsFinal and -XX:+PrintFlagsInitial 打印所有 XX 参数及值 -XX:+PrintCommandLineFlags打印出那些已经被用户或者 JVM 设置过的详细的 XX 参数的名称和值 -XX:+HeapDumpOnOutOfMemoryError and -XX:HeapDumpPath 堆内存快照 -XX:OnOutOfMemoryError 当内存溢发生时，我们甚至可以可以执行一些指令 -XX:PermSize and -XX:MaxPermSize 永久代堆内存 -XX:InitialCodeCacheSize and -XX:ReservedCodeCacheSize代码缓存 -XX:+UseCodeCacheFlushing当代码缓存被填满时让 JVM 放弃一些编译代码内存调优所有已制定的 HotSpot 内存管理和垃圾回收算法都基于一个相同的堆内存划分：新生代（young generation）里存储着新分配的和较年轻的对象，老年代（old generation）里存储着长寿的对象。在此之外，永久代（permanent generation）存储着那些需要伴随整个 JVM 生命周期的对象，比如，已加载的对象的类定义或者 String 对象内部 Cache。接下来，我们将假设堆内存是按照新生代、老年代和永久代这一经典策略划分的。然而，其他的一些堆内存划分策略也是可行的，一个突出的例子就是新的 G1 垃圾回收器，它模糊了新生代和老年代之间的区别。此外，目前的开发进程似乎表明在未来的 HotSpot JVM 版本中，将不会区分老年代和永久代。 -Xms and -Xmx (or: -XX:InitialHeapSize and -XX:MaxHeapSize)指定 JVM 的初始和最大堆内存大小新生代垃圾回收 -XX:NewSize and -XX:MaxNewSize新生代只是整个堆的一部分，新生代设置的越大，老年代区域就会减少 -XX:NewRatio动态分配新生代与老生代比例 -XX:SurvivorRatio 动态分配新生代的伊甸园区与幸存区（伊甸园区大于幸存区【俩个幸存区大小相同】） -XX:+PrintTenuringDistribution -XX:InitialTenuringThreshold， -XX:MaxTenuringThreshold and -XX:TargetSurvivorRatio -XX:+NeverTenure and -XX:+AlwaysTenure GC 日志（垃圾收集）作用：记录了每一次的 GC 的执行时间和执行结果，通过分析 GC 日志可以优化堆设置和 GC 设置，或者改进应用程序的对象分配模式 -XX:+PrintGC（- verbose:gc） 简单日志模式 123每一次新生代（young generation）的 GC 和每一次的 Full GC 打印一行信息。[GC 246656K-&gt;243120K(376320K), 0.0929090 secs]gc类型 gc使用的前的堆空间 gc使用后的堆大小 当前堆容量 gc持续时间 XX:PrintGCDetails 详细 GC 日志模式 123456[GC[PSYoungGen: 142816K-&gt;10752K(142848K)] 246648K-&gt;243136K(375296K), 0.0935090 secs][Times: user=0.55 sys=0.10, real=0.09 secs]这是一次在 young generation 中的 GC，它将已使用的堆空间从 246648K 减少到了 243136K，用时 0.0935090 秒。此外我们还可以得到更多的信息：所使用的垃圾收集器（即 PSYoungGen）、young generation 的大小和使用情况（在这个例子中 “PSYoungGen” 垃圾收集器将 young generation 所使用的堆空间从 142816K 减少到 10752K）。CPU 时间信息 =用户空间+系统空间real gc运行真实时间 -XX:+PrintGCTimeStamps 和 - XX:+PrintGCDateStamps【绝对时间】将时间和日期也加到 GC 日志中 -Xloggc（- XX:+PrintGC - XX:+PrintGCTimeStamps）输出到指定的文件","categories":[{"name":"Java","slug":"Java","permalink":"https://github.com/xuegangliu/blog/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://github.com/xuegangliu/blog/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"https://github.com/xuegangliu/blog/tags/JVM/"}]},{"title":"设计模式","slug":"设计模式","date":"2017-07-19T13:33:02.000Z","updated":"2017-07-13T15:33:02.000Z","comments":true,"path":"2017/07/19/设计模式/","link":"","permalink":"https://github.com/xuegangliu/blog/2017/07/19/设计模式/","excerpt":"","text":"设计模式(Design pattern)设计模式简介 设计模式(Design pattern) 代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。 设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。 这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。 设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。 使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。 项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。 设计模式原则 开闭原则（Open Close Principle） 开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。 里氏代换原则（Liskov Substitution Principle） 里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。 依赖倒转原则（Dependence Inversion Principle） 这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。 接口隔离原则（Interface Segregation Principle） 这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。 迪米特法则，又称最少知道原则（Demeter Principle） 最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。 合成复用原则（Composite Reuse Principle） 合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。 设计模式的使用 开发人员的共同平台 设计模式提供了一个标准的术语系统，且具体到特定的情景。例如，单例设计模式意味着使用单个对象，这样所有熟悉单例设计模式的开发人员都能使用单个对象，并且可以通过这种方式告诉对方，程序使用的是单例模式。 最佳的实践 设计模式已经经历了很长一段时间的发展，它们提供了软件开发过程中面临的一般问题的最佳解决方案。学习这些模式有助于经验不足的开发人员通过一种简单快捷的方式来学习软件设计。 设计模式类型创建型模式 这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用新的运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。 工厂模式（Factory Pattern） 抽象工厂模式（Abstract Factory Pattern） 单例模式（Singleton Pattern） 建造者模式（Builder Pattern） 原型模式（Prototype Pattern） 结构型模式 这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。 适配器模式（Adapter Pattern） 桥接模式（Bridge Pattern） 过滤器模式（Filter、Criteria Pattern） 组合模式（Composite Pattern） 装饰器模式（Decorator Pattern） 外观模式（Facade Pattern） 享元模式（Flyweight Pattern） 代理模式（Proxy Pattern） 行为型模式 这些设计模式特别关注对象之间的通信。 责任链模式（Chain of Responsibility Pattern） 命令模式（Command Pattern） 解释器模式（Interpreter Pattern） 迭代器模式（Iterator Pattern） 中介者模式（Mediator Pattern） 备忘录模式（Memento Pattern） 观察者模式（Observer Pattern） 状态模式（State Pattern） 空对象模式（Null Object Pattern） 策略模式（Strategy Pattern） 模板模式（Template Pattern） 访问者模式（Visitor Pattern） J2EE 模式 这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。 MVC 模式（MVC Pattern） 业务代表模式（Business Delegate Pattern） 组合实体模式（Composite Entity Pattern） 数据访问对象模式（Data Access Object Pattern） 前端控制器模式（Front Controller Pattern） 拦截过滤器模式（Intercepting Filter Pattern） 服务定位器模式（Service Locator Pattern） 传输对象模式（Transfer Object Pattern） 设计模式直接的关系","categories":[{"name":"Java","slug":"Java","permalink":"https://github.com/xuegangliu/blog/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://github.com/xuegangliu/blog/tags/Java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://github.com/xuegangliu/blog/tags/设计模式/"}]},{"title":"docker基础","slug":"docker基础","date":"2017-01-09T14:08:37.000Z","updated":"2017-01-09T14:08:37.000Z","comments":true,"path":"2017/01/09/docker基础/","link":"","permalink":"https://github.com/xuegangliu/blog/2017/01/09/docker基础/","excerpt":"","text":"docker service docker start systemctl start docker systemctl enable docker Docker 中国官方镜像加速可通过 registry.docker-cn.comdocker --registry-mirror=https://registry.docker-cn.com daemon 为了永久性保留更改，您可以修改 /etc/docker/daemon.json 文件并添加上 registry-mirrors 键值。 123456&#123; &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;]&#125;docker --registry-mirror=https://registry.docker-cn.com daemondocker run --name some-mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag mysql ALTER USER ‘root‘@’%’ IDENTIFIED WITH mysql_native_password BY ‘你的密码’;FLUSH PRIVILEGES; mongo docker pull mongo docker run –name some-mongo -p 27017:27017 -d mongo –auth //这里的–name 放在前面并映射端口 docker exec -it 容器ID /bin/bash //进入容器 mongo use admin db.createUser({user:”root”,pwd:”root”,roles:[{role:’root’,db:’admin’}]}) //创建用户,此用户创建成功,则后续操作都需要用户认证 exit ftp12docker pull docker.io/fauria/vsftpddocker run -d -v /home/vsftpd:/home/vsftpd -p 20:20 -p 21:21 -p 21100-21110:21100-21110 -e FTP_USER=test -e FTP_PASS=test --name vsftpd fauria/vsftpd 会以登录用户名 (test) 创建一个目录 (/home/vsftpd/test) 作为 ftp 根目录 测试时发现不加 -p 20:20 依然可以正常操作 sftp 使用命令sudo docker pull luzifer/sftp-share 构建docker run -d -p 2022:22 -e USER=myuser -e PASS=myverysecretpassword luzifer/sftp-share","categories":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/xuegangliu/blog/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/xuegangliu/blog/tags/Linux/"},{"name":"Docker","slug":"Docker","permalink":"https://github.com/xuegangliu/blog/tags/Docker/"}]},{"title":"Oracle常用Sql","slug":"Oracle常用Sql","date":"2016-12-04T10:03:46.000Z","updated":"2016-12-04T10:03:46.000Z","comments":true,"path":"2016/12/04/Oracle常用Sql/","link":"","permalink":"https://github.com/xuegangliu/blog/2016/12/04/Oracle常用Sql/","excerpt":"","text":"Oracle 常用SQL基本12345678910111213141516171819202122--新建表： create table table1( id varchar(300) primary key, name varchar(200) not null);--插入数据 insert into table1 (id,name) values (&apos;aa&apos;,&apos;bb&apos;);--更新数据 update table1 set id = &apos;bb&apos; where id=&apos;cc&apos;;--删除数据 delete from table1 where id =&apos;cc&apos;;--删除表 drop table table1;--修改表名： alter table table1 rename to table2--表数据复制： insert into table1 (select * from table2);--复制表结构： create table table1 select * from table2 where 1&gt;1;--复制表结构和数据： create table table1 select * from table2;--复制指定字段： create table table1 as select id, name from table2 where 1&gt;1;--条件查询： select id,name (case gender when 0 then &apos;男&apos; when 1 then ‘女’ end ) gender from table1 数学函数123456789101112131415161718192021222324252627--绝对值：abs() select abs(-2) value from dual; --(2)--取整函数（大）：ceil（） select ceil(-2.001) value from dual; --(-2)--取整函数（小）：floor（） select floor(-2.001) value from dual; --(-3)--取整函数（截取）：trunc（） select trunc(-2.001) value from dual; -- (-2)--四舍五入：round（） select round(1.234564,4) value from dual; --(1.2346)--取平方：Power（m,n） select power(4,2) value from dual; --(16)--取平方根:SQRT() select sqrt(16) value from dual; --(4)--取随机数:dbms_random(minvalue,maxvalue) select dbms_random.value() from dual; (默认是0到1之间) select dbms_random.value(2,4) value from dual; （2-4之间随机数）--取符号：Sign() select sign(-3) value from dual; --(-1) select sign(3) value from dual; --(1)--取集合的最大值:greatest(value) select greatest(-1,3,5,7,9) value from dual; --(9)--取集合的最小值:least(value) select least(-1,3,5,7,9) value from dual; --(-1)--处理Null值：nvl(空值，代替值) select nvl(null,10) value from dual; --(10) select nvl(score,10) score from student; rownum相关12345678910111213--rownum小于某个数时可以直接作为查询条件（注意oracle不支持select top）select * from student where rownum &lt;3;--查询rownum大于某个数值,需要使用子查询，并且rownum需要有别名select * from(select rownum rn ,id,name from student) where rn&gt;2;select * from (select rownum rn, student.* from student) where rn &gt;3;--区间查询select * from (select rownum rn, student.* from student) where rn &gt;3 and rn&lt;6;--排序+前n条select * from (select rownum rn, t.* from ( select d.* from DJDRUVER d order by drivernumber)t )p where p.rn&lt;10;--排序+区间查询1select * from (select rownum rn, t.* from ( select d.* from DJDRIVER d order by DJDRIVER_DRIVERTIMES)t )p where p.rn&lt;9 and p.rn&gt;6;--排序+区间查询2select * from (select rownum rn, t.* from ( select d.* from DJDRIVER d order by DJDRIVER_DRIVERTIMES)t where rownum&lt;9 )p where p.rn&gt;6;--效率远高于方式一 分页查询1234567891011--效率低select * from (select rownum rn, d.* from DJDRIVER d )p where p.rn&lt;=20 and p.rn&gt;=10;select * from (select rownum rn, d.* from DJDRIVER d )p where p.rn between 10 and 20;--效率高 select * from (select rownum rn, d.* from DJDRIVER d where rownum&lt;=20 )p where p.rn&gt;=10;--排序+区间查询1（效率低）select * from (select rownum rn, t.* from ( select d.* from DJDRIVER d order by DJDRIVER_DRIVERTIMES)t )p where p.rn&lt;=20 and p.rn&gt;=10;select * from (select rownum rn, t.* from ( select d.* from DJDRIVER d order by DJDRIVER_DRIVERTIMES)t )p where p.rn between 10 and 20;--排序+区间查询2（效率高） select * from (select rownum rn, t.* from ( select d.* from DJDRIVER d order by DJDRIVER_DRIVERTIMES)t where rownum&lt;=20 )p where p.rn&gt;=10; 时间处理日期年 yyyy yyy yy year月 month mm mon month日+星期 dd ddd(一年中第几天) dy day小时 hh hh24分 mi秒 ss12345678910111213select to_char(sysdate,&apos;yyyy-mm-dd hh24:mi:ss&apos;)currenttime, to_char(sysdate,&apos;yyyy&apos;) year, to_char(sysdate,&apos;mm&apos;) month, to_char(sysdate,&apos;dd&apos;) day, to_char(sysdate,&apos;day&apos;) week, to_char(sysdate,&apos;hh24&apos;)hour, to_char(sysdate,&apos;mi&apos;) minute, to_char(sysdate,&apos;ss&apos;) secondfrom dual;months_between(to_date(&apos;03-31-2014&apos;,&apos;MM-DD-YYYY&apos;),to_date(&apos;12-31-2013&apos;,&apos;MM-DD-YYYY&apos;)) next_day(sysdate,6) oracle基本sql","categories":[{"name":"Oracle","slug":"Oracle","permalink":"https://github.com/xuegangliu/blog/categories/Oracle/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://github.com/xuegangliu/blog/tags/Oracle/"},{"name":"SQL","slug":"SQL","permalink":"https://github.com/xuegangliu/blog/tags/SQL/"}]},{"title":"Vim使用","slug":"Vim使用","date":"2016-11-09T15:10:43.000Z","updated":"2016-11-09T15:10:43.000Z","comments":true,"path":"2016/11/09/Vim使用/","link":"","permalink":"https://github.com/xuegangliu/blog/2016/11/09/Vim使用/","excerpt":"","text":"vim 基本使用 命令模式刚刚启动 vi/vim，便进入了命令模式。此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。以下是常用的几个命令： i 切换到输入模式，以输入字符。 x 删除当前光标所在处的字符。 : 切换到底线命令模式，以在最底一行输入命令。 若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。 命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。 输入模式命令模式下按下i就进入了输入模式。在输入模式中，可以使用以下按键： 字符按键以及Shift组合，输入字符 ENTER，回车键，换行 BACK SPACE，退格键，删除光标前一个字符 DEL，删除键，删除光标后一个字符 方向键，在文本中移动光标 HOME/END，移动光标到行首/行尾 Page Up/Page Down，上/下翻页 Insert，切换光标为输入/替换模式，光标将变成竖线/下划线 ESC，退出输入模式，切换到命令模式 底线命令模式在命令模式下按下:（英文冒号）就进入了底线命令模式。底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。在底线命令模式中，基本的命令有（已经省略了冒号）： q 退出程序 w 保存文件 ESC键可随时退出底线命令模式。 快捷键一般模式可用的光标移动、复制粘贴、搜索替换等移动光标的方法 h 或 向左箭头键(←) 光标向左移动一个字符 j 或 向下箭头键(↓) 光标向下移动一个字符 k 或 向上箭头键(↑) 光标向上移动一个字符 l 或 向右箭头键(→) 光标向右移动一个字符 如果想要进行多次移动的话，例如向下移动 30 行，可以使用 “30j” 或 “30↓” 的组合按键， 亦即加上想要进行的次数(数字)后，按下动作即可！ [Ctrl] + [f] 屏幕『向下』移动一页，相当于 - - - [Page Down]按键 (常用) [Ctrl] + [b] 屏幕『向上』移动一页，相当于 - - - [Page Up] 按键 (常用) [Ctrl] + [d] 屏幕『向下』移动半页 [Ctrl] + [u] 屏幕『向上』移动半页 光标移动到非空格符的下一行 光标移动到非空格符的上一行 n 那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20 则光标会向后面移动 20 个字符距离。 0 或功能键[Home] 这是数字『 0 』：移动到这一行的最前面字符处 (常用) $ 或功能键[End] 移动到这一行的最后面字符处(常用) H 光标移动到这个屏幕的最上方那一行的第一个字符 M 光标移动到这个屏幕的中央那一行的第一个字符 L 光标移动到这个屏幕的最下方那一行的第一个字符 G 移动到这个档案的最后一行(常用) nG n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu) gg 移动到这个档案的第一行，相当于 1G 啊！ (常用) n n 为数字。光标向下移动 n 行(常用) 搜索替换 /word 向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！ (常用) ?word 向光标之上寻找一个字符串名称为 word 的字符串。 n 这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！ N 这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。 使用 /word 配合 n 及 N 是非常有帮助的！可以让你重复的找到一些你搜寻的关键词！ :n1,n2s/word1/word2/g n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则： 『:100,200s/vbird/VBIRD/g』。(常用) :1,$s/word1/word2/g 从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用) :1,$s/word1/word2/gc 从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用) 删除、复制与贴上 x, X 在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用) nx n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。 dd 删除游标所在的那一整行(常用) ndd n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行 (常用) d1G 删除光标所在到第一行的所有数据 dG 删除光标所在到最后一行的所有数据 d$ 删除游标所在处，到该行的最后一个字符 d0 那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符 yy 复制游标所在的那一行(常用) nyy n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用) y1G 复制游标所在行到第一行的所有数据 yG 复制游标所在行到最后一行的所有数据 y0 复制光标所在的那个字符到该行行首的所有数据 y$ 复制光标所在的那个字符到该行行尾的所有数据 p, P p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用) J 将光标所在行与下一行的数据结合成同一行 c 重复删除多个数据，例如向下删除 10 行，[ 10cj ] u 复原前一个动作。(常用) [Ctrl]+r 重做上一个动作。(常用) 这个 u 与 [Ctrl]+r 是很常用的指令！一个是复原，另一个则是重做一次～ 利用这两个功能按键，你的编辑，嘿嘿！很快乐的啦！ . 不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用) 一般模式切换到编辑模式的可用的按钮说明进入输入或取代的编辑模式 i, I 进入输入模式(Insert mode)：i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 (常用) a, A 进入输入模式(Insert mode)：a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用) o, O 进入输入模式(Insert mode)：这是英文字母 o 的大小写。o 为『在目前光标所在的下一行处输入新的一行』； O 为在目前光标所在处的上一行输入新的一行！(常用) r, R 进入取代模式(Replace mode)：r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)在 vi 画面的左下角处会出现『--INSERT--』或『--REPLACE--』的字样 才能输入 [Esc] 退出编辑模式，回到一般模式中(常用) 一般模式切换到指令行模式的可用的按钮说明指令行的储存、离开等指令 :w 将编辑的数据写入硬盘档案中(常用) :w! 若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！ :q 离开 vi (常用) :q! 若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～ :wq 储存后离开，若为 :wq! 则为强制储存后离开 (常用)ZZ 这是大写的 Z 喔！若档案没有更动，则不储存离开，若档案已经被更动过，则储存后离开！ :w [filename] 将编辑的数据储存成另一个档案（类似另存新档） :r [filename] 在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面 :n1,n2 w [filename] 将 n1 到 n2 的内容储存成 filename 这个档案。 :! command 暂时离开 vi 到指令行模式下执行 command 的显示结果！例如『:! ls /home』即可在 vi 当中察看 /home 底下以 ls 输出的档案信息！ vim 环境的变更 :set nu 显示行号，设定之后，会在每一行的前缀显示该行的行号 :set nonu 与 set nu 相反，为取消行号！","categories":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/xuegangliu/blog/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/xuegangliu/blog/tags/Linux/"},{"name":"Vim","slug":"Vim","permalink":"https://github.com/xuegangliu/blog/tags/Vim/"}]},{"title":"Linux工具","slug":"Linux工具","date":"2016-11-09T15:07:29.000Z","updated":"2016-11-09T15:07:29.000Z","comments":true,"path":"2016/11/09/Linux工具/","link":"","permalink":"https://github.com/xuegangliu/blog/2016/11/09/Linux工具/","excerpt":"","text":"程序构建1.配置 -&gt; 2.编译 -&gt; 3.安装 配置做的工作主要是检查当前环境是否满足要安装软件的依赖关系，以及设置程序安装所需要的初始化信息，比如安装路径，需要安装哪些组件；配置完成，会生成makefile文件供第二步make使用； 编译是对源文件进行编译链接生成可执行程序； 安装做的工作就简单多了，就是将生成的可执行文件拷贝到配置时设置的初始路径下； 1234./configure --help./configure --prefix=/usr/local/snmpmake -f myMakefilemake install 程序调试gdb 程序交互调试 性能优化系统123topfreevmstat 进入交互模式后:输入M，进程列表按内存使用大小降序排序，便于我们观察最大内存使用者使用有问题（检测内存泄漏问题）;输入P，进程列表按CPU使用大小降序排序，便于我们观察最耗CPU资源的使用者是否有问题；top第三行显示当前系统的，其中有两个值很关键:%id：空闲CPU时间百分比，如果这个值过低，表明系统CPU存在瓶颈；%wa：等待I/O的CPU时间百分比，如果这个值过高，表明IO存在瓶颈； 程序如果IO存在性能瓶颈，top工具中的%wa会偏高；进一步分析使用iostat工具如果%iowait的值过高，表示硬盘存在I/O瓶颈。如果 %util 接近 100%，说明产生的I/O请求太多，I/O系统已经满负荷，该磁盘可能存在瓶颈。如果 svctm 比较接近 await，说明 I/O 几乎没有等待时间；如果 await 远大于 svctm，说明I/O 队列太长，io响应太慢，则需要进行必要优化。如果avgqu-sz比较大，也表示有大量io在等待。 分析进程调用 pstack用来跟踪进程栈 pstack [pid] strace用来跟踪进程中的系统调用","categories":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/xuegangliu/blog/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/xuegangliu/blog/tags/Linux/"},{"name":"Tools","slug":"Tools","permalink":"https://github.com/xuegangliu/blog/tags/Tools/"}]},{"title":"Python基础","slug":"Python基础","date":"2016-11-08T14:49:38.000Z","updated":"2016-11-08T14:49:38.000Z","comments":true,"path":"2016/11/08/Python基础/","link":"","permalink":"https://github.com/xuegangliu/blog/2016/11/08/Python基础/","excerpt":"","text":"python3 规定 缩进规定、多行语句(+) 指定源码编码# -*- coding: utf-8 -*- #coding=utf8 注释123456789# 方法1&apos;&apos;&apos;注释方法2&apos;&apos;&apos;&quot;&quot;&quot;注释方法3&quot;&quot;&quot; 标准数据类型 Number 数字(int、bool、float、complex) ,不可变 String 字符串, 不可变, 序列 ‘’’aa’’’ “””bbb””” \\转义字符 r不转义 索引从0开始，从-1倒序 List 列表, [] ,序列, 有序 Tuple 元组 ,不可变 ,(), 序列 Set 集合 {xx} 或者 set() Dictionary 字典, 无序, {key:value} 类型判断注意 tpye() 不会认为子类是一种父类类型 isinstance()会认为子类是一种父类类型 is 用于判断两个变量引用对象是否为同一个， == 用于判断引用变量的值是否相等。 模块 模块导入 import 与 from xx import a,b,c 面向对象 类属性与方法 __private_attrs：两个下划线开头，声明该属性为私有 类的方法 第一个参数必须为self __private_method：两个下划线开头，私有方法 类的专有方法： init : 构造函数，在生成对象时调用 del : 析构函数，释放对象时使用 repr : 打印，转换 setitem : 按照索引赋值 getitem: 按照索引获取值 len: 获得长度 cmp: 比较运算 call: 函数调用 add: 加运算 sub: 减运算 mul: 乘运算 div: 除运算 mod: 求余运算 pow: 乘方 错误异常12345try: breakexcept ValueError: //","categories":[{"name":"Python","slug":"Python","permalink":"https://github.com/xuegangliu/blog/categories/Python/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"https://github.com/xuegangliu/blog/tags/Shell/"},{"name":"Python","slug":"Python","permalink":"https://github.com/xuegangliu/blog/tags/Python/"}]},{"title":"Java反射基础","slug":"Java反射基础","date":"2016-07-28T10:30:12.000Z","updated":"2016-07-28T10:30:12.000Z","comments":true,"path":"2016/07/28/Java反射基础/","link":"","permalink":"https://github.com/xuegangliu/blog/2016/07/28/Java反射基础/","excerpt":"","text":"Java 反射在运行中，可以使程序创建和控制任何类的对象。 缺点 性能: 对类的逻辑结构信息获取后，然后对这些类进行操作（所以相对于源码方式速度较低） 模糊程序内部处理逻辑等 Java reflection使类和数据结构按名称动态检索相关的信息并可以操作这些信息。 java.lang.reflect.*(Field,Method,Constructor)java.lang.Class 反射的实现方式 通过对象的getClass()，例如：String.getClass 通过对象实例方法获取，例如：String.classs 通过Class.forName(“java.lang.String”),加载时，会将对应的静态方法加载","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://github.com/xuegangliu/blog/categories/Java基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://github.com/xuegangliu/blog/tags/Java/"}]}]}