<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>俩天的博客</title>
  
  <subtitle>日常记录</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://github.com/xuegangliu/blog/"/>
  <updated>2019-11-06T10:30:12.000Z</updated>
  <id>https://github.com/xuegangliu/blog/</id>
  
  <author>
    <name>xuegangliu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JDK1.5新特性</title>
    <link href="https://github.com/xuegangliu/blog/2019/11/06/java/java_5_skill/"/>
    <id>https://github.com/xuegangliu/blog/2019/11/06/java/java_5_skill/</id>
    <published>2019-11-06T10:30:12.000Z</published>
    <updated>2019-11-06T10:30:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JDK1-5新特性"><a href="#JDK1-5新特性" class="headerlink" title="JDK1.5新特性"></a>JDK1.5新特性</h3><ol><li><p>自动装箱与拆箱<br> 基本数据类型与封装的基本类型互相转换</p></li><li><p>枚举<br> java.lang.Enum</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.annotation;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Annotation retention policy.  The constants of this enumerated type</span></span><br><span class="line"><span class="comment"> * describe the various policies for retaining annotations.  They are used</span></span><br><span class="line"><span class="comment"> * in conjunction with the &#123;<span class="doctag">@link</span> Retention&#125; meta-annotation type to specify</span></span><br><span class="line"><span class="comment"> * how long annotations are to be retained.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  Joshua Bloch</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> RetentionPolicy &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Annotations are to be discarded by the compiler.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SOURCE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Annotations are to be recorded in the class file by the compiler</span></span><br><span class="line"><span class="comment">     * but need not be retained by the VM at run time.  This is the default</span></span><br><span class="line"><span class="comment">     * behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CLASS,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Annotations are to be recorded in the class file by the compiler and</span></span><br><span class="line"><span class="comment">     * retained by the VM at run time, so they may be read reflectively.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> java.lang.reflect.AnnotatedElement</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RUNTIME</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>静态导入<br><code>import static java.lang.Math.PI;</code></p></li><li><p>可变参数（Varargs）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * This is description</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xuegangliu 2019/11/06</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> A().test(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span>... a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> t:a)&#123;</span><br><span class="line">            System.out.println(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>内省（Introspector），访问某个对象属性的 getter/setter 方法的API。<br><code>java.beans.*</code></p></li><li><p>泛型(Generic)（包括通配类型/边界类型等）</p></li><li><p>For-Each循环</p></li><li><p>注解</p></li><li><p>协变返回类型：实际返回类型可以是要求的返回类型的一个子类型</p></li></ol><details><br>  <summary>5.6.7.8.9代码示例</summary><br>  <br><br>  <code><br>package org.lxg.basic.jdk5;<br><br>import lombok.extern.slf4j.Slf4j;<br>import org.junit.Test;<br>import org.lxg.basic.annotation.AnnotationA;<br>import org.lxg.basic.annotation.AnnotationB;<br>import org.lxg.basic.annotation.BasicInfo;<br>import org.lxg.basic.annotation.filed.BaseFiled;<br>import org.lxg.basic.annotation.method.BasicMethod;<br><br>import java.beans.BeanInfo;<br>import java.beans.IntrospectionException;<br>import java.beans.Introspector;<br>import java.beans.PropertyDescriptor;<br>import java.lang.reflect.Field;<br>import java.lang.reflect.InvocationTargetException;<br>import java.lang.reflect.Method;<br>import java.util.ArrayList;<br>import java.util.List;<br><br>import static java.lang.Math.max;<br><br>/<strong><br> <em> Jdk5Tests </em> <p><br> <em> This is description </em> </p><br> <em> </em> @author xuegangliu 2019/11/06<br> * @since 1.8 </strong>/<br>@Slf4j<br>public class Jdk5Tests {<br>    @Test<br>    public void testAnnotationA(){<br>        Class clsA = AnnotationA.class;<br>        log.info(“clsA class:{}”,clsA.getName());<br><br>        BasicInfo basicTypeA = (BasicInfo) clsA.getAnnotation(BasicInfo.class);<br>        log.info(“clsA {},{}”,basicTypeA.version(),basicTypeA.description());<br><br><br>        Field[] fields1 = clsA.getDeclaredFields();<br>        log.info(“———– field ——————-“);<br>//        Field[] fields = clsA.getFields();<br>//        for (Field field : fields) {<br>//            BaseFiled baseFiled = field.getAnnotation(BaseFiled.class);<br>//            if (baseFiled != null) {<br>//                log.info(“field:{},{},{}”,field.getName(),baseFiled.description(),baseFiled.Old());<br>//            }<br>//        }<br>        for (Field field : fields1) {<br>            BaseFiled baseFiled = field.getAnnotation(BaseFiled.class);<br>            if (baseFiled != null) {<br>                log.info(“field:{},{},{}”,field.getName(),baseFiled.description(),baseFiled.Old());<br>            }<br>        }<br>        log.info(“———— methods ——————“);<br>        Method[] methods = clsA.getDeclaredMethods();<br>        for(Method method:methods){<br>            BasicMethod methodInfo=method.getAnnotation(BasicMethod.class);<br>            if(methodInfo!=null){<br>                log.info(“Annotation: method:{},author:{},date:{},version:{}”,method.getName(),methodInfo.author(),methodInfo.date(),methodInfo.version());<br>            }<br>        }<br>    }<br><br>    @Test<br>    public void testAnnotationB(){<br>        Class clsB = AnnotationB.class;<br>        log.info(“clsB class:{}”,clsB.getName());<br><br>        BasicInfo basicTypeB = (BasicInfo) clsB.getAnnotation(BasicInfo.class);<br>        log.info(“clsB {},{}”,basicTypeB.version(),basicTypeB.description());<br><br><br>        Field[] fields1 = clsB.getDeclaredFields();<br>        log.info(“———– field ——————-“);<br>//        Field[] fields = clsA.getFields();<br>//        for (Field field : fields) {<br>//            BaseFiled baseFiled = field.getAnnotation(BaseFiled.class);<br>//            if (baseFiled != null) {<br>//                log.info(“field:{},{},{}”,field.getName(),baseFiled.description(),baseFiled.Old());<br>//            }<br>//        }<br>        for (Field field : fields1) {<br>            BaseFiled baseFiled = field.getAnnotation(BaseFiled.class);<br>            if (baseFiled != null) {<br>                log.info(“field:{},{},{}”,field.getName(),baseFiled.description(),baseFiled.Old());<br>            }<br>        }<br>        log.info(“———— methods ——————“);<br>        Method[] methods = clsB.getDeclaredMethods();<br>        for(Method method:methods){<br>            BasicMethod methodInfo=method.getAnnotation(BasicMethod.class);<br>            if(methodInfo!=null){<br>                log.info(“Annotation: method:{},author:{},date:{},version:{}”,method.getName(),methodInfo.author(),methodInfo.date(),methodInfo.version());<br>            }<br>        }<br>    }<br><br>    @Test<br>    public void testBox(){<br>        int i=1;<br>        Integer j=i;<br>        log.error(“int i:{},Integer j:{}”,i,j);<br><br>        Integer x=256;<br>        int y=x;<br>        log.error(“Integer x:{},int y:{}”,x,y);<br>    }<br><br>    @Test<br>    public void testEnum(){<br>        for (EnumA e : EnumA.values()) {<br>            log.error(“code:{},msg:{}”,e.code,e.msg);<br>        }<br>    }<br><br>    @Test<br>    public void testImportStatic(){<br>        log.error(“(import static java.lang.Math.max) max(11,12):{}”,max(11,12));<br>    }<br><br>    @Test<br>    public void testChangeArgs(){<br>        Jdk5Tests.changeArgs(1,2,3,5,4);<br>    }<br><br>    @Test<br>    public void testBeanGetSet() throws IntrospectionException, InvocationTargetException, IllegalAccessException {<br>        Student student = new Student(“Tony”,28);<br><br>        PropertyDescriptor propertyDescriptorName = new PropertyDescriptor(“name”, Student.class);<br>        Method writeNameMethod = propertyDescriptorName.getWriteMethod();<br>        Method readNameMethod = propertyDescriptorName.getReadMethod();<br>        log.error(“{}”,readNameMethod.invoke(student).toString());<br>        writeNameMethod.invoke(student, “Tony1”);<br>        log.error(“{}”,readNameMethod.invoke(student).toString());<br><br>        BeanInfo beanInfo = Introspector.getBeanInfo(student.getClass());<br>        PropertyDescriptor[] pd = beanInfo.getPropertyDescriptors();<br>        for (int i = 0; i &lt; pd.length; i++) {<br>            PropertyDescriptor p=pd[i];<br>            log.error(“{}”,p.getName());<br>        }<br>    }<br><br>    @Test<br>    public void testGeneric(){<br>        List<integer> list = new ArrayList<integer>();<br>        list.add(1);<br>//        list.add(“err”);<br>        log.error(“size:{}”,list.size());<br>    }<br><br>    @Test<br>    public void testForEach(){<br>        Student tony=new Student(“Tony”,11);<br>        Student lily=new Student(“Lily”,13);<br>        List<student> list=new ArrayList<student>();<br>        list.add(tony);<br>        list.add(lily);<br><br>        for (Student student : list) {<br>            log.error(“name:{},age:{}”,student.getName(),student.getAge());<br>        }<br>    }<br><br>//    public ? super Student changeReturn(){<br>//<br>//        return null;<br>//    }<br><br>    public static void changeArgs(int… args){<br>        for (int i = 0; i &lt; args.length; i++) {<br>            log.error(“{}”,args[i]);<br>        }<br>    }<br><br>    private enum EnumA{<br>        OK(200,”OK”),<br>        NO(404,”No”);<br><br>        private String msg;<br>        private Integer code;<br>        EnumA(Integer code,String msg){<br>            this.msg=msg;<br>            this.code=code;<br>        }<br>    }<br>}<br>class Base{<br><br>    public Base(){}<br><br>    public List<object> getList(){<br>        return new ArrayList&lt;&gt;();<br>    }<br><br>}<br><br>class Student extends Base{<br>    private String name;<br>    private Integer age;<br><br>    public Student(String name,Integer age){<br>        this.name=name;<br>        this.age=age;<br>    }<br><br>    public String getName() {<br>        return name;<br>    }<br><br>    public void setName(String name) {<br>        this.name = name;<br>    }<br><br>    public Integer getAge() {<br>        return age;<br>    }<br><br>    public void setAge(Integer age) {<br>        this.age = age;<br>    }<br><br>    @Override<br>    public ArrayList<object> getList(){<br>        // 重新父类方法,返回值是父类返回值的子类即协变返回类型<br>        return new ArrayList&lt;&gt;();<br>    }<br>}<br><br>  </object></object></student></student></integer></integer></code><br></details>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;JDK1-5新特性&quot;&gt;&lt;a href=&quot;#JDK1-5新特性&quot; class=&quot;headerlink&quot; title=&quot;JDK1.5新特性&quot;&gt;&lt;/a&gt;JDK1.5新特性&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;自动装箱与拆箱&lt;br&gt; 基本数据类型与封装的基本类型互相转换&lt;/p
      
    
    </summary>
    
      <category term="java" scheme="https://github.com/xuegangliu/blog/categories/java/"/>
    
    
      <category term="knowledge" scheme="https://github.com/xuegangliu/blog/tags/knowledge/"/>
    
      <category term="java_base" scheme="https://github.com/xuegangliu/blog/tags/java-base/"/>
    
  </entry>
  
  <entry>
    <title>开发中遇到的问题记录</title>
    <link href="https://github.com/xuegangliu/blog/2019/08/30/problem/work-problem/"/>
    <id>https://github.com/xuegangliu/blog/2019/08/30/problem/work-problem/</id>
    <published>2019-08-30T10:20:53.000Z</published>
    <updated>2019-08-30T10:20:53.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="开发中遇到的问题记录"><a href="#开发中遇到的问题记录" class="headerlink" title="开发中遇到的问题记录"></a>开发中遇到的问题记录</h3><h4 id="1-idea启动项目后页面不能访问"><a href="#1-idea启动项目后页面不能访问" class="headerlink" title="1.idea启动项目后页面不能访问"></a>1.idea启动项目后页面不能访问</h4><p>解决方案：新版本部署tomcat需要勾选Deploy</p><h4 id="2-idea中启动tomcat项目，控制台乱码"><a href="#2-idea中启动tomcat项目，控制台乱码" class="headerlink" title="2.idea中启动tomcat项目，控制台乱码"></a>2.idea中启动tomcat项目，控制台乱码</h4><ul><li>原因：tomcat编码与本地环境编码不一致</li><li>解决方案：在catalina.out|catalina.sh文件中的JAVA_OPTS后加<code>-Dfile.encoding=UTF8 -Dsun.jnu.encoding=UTF8</code></li></ul><h4 id="3-公网无法下载，安装jar到本地仓库"><a href="#3-公网无法下载，安装jar到本地仓库" class="headerlink" title="3.公网无法下载，安装jar到本地仓库"></a>3.公网无法下载，安装jar到本地仓库</h4><ul><li><code>mvn install:install-file -Dfile=jar包的位置 -DgroupId=jar包的groupId -DartifactId=jar包的artifactId -Dversion=jar包的version -Dpackaging=jar</code></li></ul><h4 id="4-用一些证书后，报java-security-InvalidKeyException-Illegal-key-size异常"><a href="#4-用一些证书后，报java-security-InvalidKeyException-Illegal-key-size异常" class="headerlink" title="4.用一些证书后，报java.security.InvalidKeyException: Illegal key size异常"></a>4.用一些证书后，报java.security.InvalidKeyException: Illegal key size异常</h4><ul><li>原因：安全证书果密钥大于128报错，java默认的安全证书是受限制的</li><li>解决方案：替换环境中%JDK_HOME%\jre\lib\security目录下的local_policy.jar和US_export_policy.jar</li><li><a href="https://www.cnblogs.com/lilinzhiyu/p/8024100.html" target="_blank" rel="noopener">blog文章</a></li></ul><h4 id="5-springboot中jpa默认的查询中，对象与数据表的映射时，当数据库中表中字段为null时，查询错误"><a href="#5-springboot中jpa默认的查询中，对象与数据表的映射时，当数据库中表中字段为null时，查询错误" class="headerlink" title="5.springboot中jpa默认的查询中，对象与数据表的映射时，当数据库中表中字段为null时，查询错误"></a>5.springboot中jpa默认的查询中，对象与数据表的映射时，当数据库中表中字段为null时，查询错误</h4><ul><li>原因：对象映射字段为基本类型导致null映射错误</li><li>解决方案：将基本数据类型修改为包装类型</li></ul><h4 id="6-oracle-merge-into用到自增序列-生成多次无用的序列"><a href="#6-oracle-merge-into用到自增序列-生成多次无用的序列" class="headerlink" title="6.oracle merge into用到自增序列,生成多次无用的序列"></a>6.oracle merge into用到自增序列,生成多次无用的序列</h4><ul><li>原因:存储过程中,对主键设置时,会造成序列很快用完</li><li><a href="https://blog.csdn.net/zlh313_01/article/details/82745526" target="_blank" rel="noopener">https://blog.csdn.net/zlh313_01/article/details/82745526</a></li></ul><h4 id="7-java-lang-UnsatisfiedLinkError-no-jacob-1-17-x64-in-java-library-path"><a href="#7-java-lang-UnsatisfiedLinkError-no-jacob-1-17-x64-in-java-library-path" class="headerlink" title="7.java.lang.UnsatisfiedLinkError: no jacob-1.17-x64 in java.library.path"></a>7.java.lang.UnsatisfiedLinkError: no jacob-1.17-x64 in java.library.path</h4><ul><li>原因：未找到匹配信息</li><li>需要把jacob-1.17-x64.dll添加到系统的变量文件下</li></ul><h4 id="8-oracle-sql语句查询-子查询查出数据不正确"><a href="#8-oracle-sql语句查询-子查询查出数据不正确" class="headerlink" title="8.oracle sql语句查询,子查询查出数据不正确"></a>8.oracle sql语句查询,子查询查出数据不正确</h4><ul><li>原因: 未按别名展示出列，(子查询中的字段在上级中存在同样字段,未添加表别名，按自身的值去查询)</li><li>字段展示，带上表别名展示</li></ul><h4 id="9-前端ajax请求数据-后端没有按key取到值"><a href="#9-前端ajax请求数据-后端没有按key取到值" class="headerlink" title="9.前端ajax请求数据,后端没有按key取到值"></a>9.前端ajax请求数据,后端没有按key取到值</h4><ul><li>原因: 传过去为string，未按key：value去传过去</li><li>按key、value格式传过去</li></ul><h4 id="10-在https服务中发ajax请求http被浏览器block"><a href="#10-在https服务中发ajax请求http被浏览器block" class="headerlink" title="10.在https服务中发ajax请求http被浏览器block"></a>10.在https服务中发ajax请求http被浏览器block</h4><ul><li>原因: (从https发送http请求是不可以)</li><li>协议，域名，端口有任何一个的不同，就被当作是跨域,请求https</li></ul><h4 id="11-ios-h5页面软键盘弹出后造成的触控不准BUG以及其解决方法"><a href="#11-ios-h5页面软键盘弹出后造成的触控不准BUG以及其解决方法" class="headerlink" title="11.ios h5页面软键盘弹出后造成的触控不准BUG以及其解决方法"></a>11.ios h5页面软键盘弹出后造成的触控不准BUG以及其解决方法</h4><ul><li>原因: ios h5页面软键盘弹出后造成的触控不准</li><li><a href="https://blog.csdn.net/soband_xiang/article/details/85697948" target="_blank" rel="noopener">https://blog.csdn.net/soband_xiang/article/details/85697948</a></li></ul><h4 id="12-hibernate-sessionFactory-hql查询完，-查询出的的bean-重新set-filed时会发生更新数据操作"><a href="#12-hibernate-sessionFactory-hql查询完，-查询出的的bean-重新set-filed时会发生更新数据操作" class="headerlink" title="12.hibernate sessionFactory hql查询完， 查询出的的bean 重新set filed时会发生更新数据操作"></a>12.hibernate sessionFactory hql查询完， 查询出的的bean 重新set filed时会发生更新数据操作</h4><ul><li>原因: sessionFactory查询完，未释放sessionFactory</li><li><a href="https://blog.csdn.net/shine0181/article/details/6187939" target="_blank" rel="noopener">https://blog.csdn.net/shine0181/article/details/6187939</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;开发中遇到的问题记录&quot;&gt;&lt;a href=&quot;#开发中遇到的问题记录&quot; class=&quot;headerlink&quot; title=&quot;开发中遇到的问题记录&quot;&gt;&lt;/a&gt;开发中遇到的问题记录&lt;/h3&gt;&lt;h4 id=&quot;1-idea启动项目后页面不能访问&quot;&gt;&lt;a href=&quot;#1-id
      
    
    </summary>
    
      <category term="problem" scheme="https://github.com/xuegangliu/blog/categories/problem/"/>
    
    
      <category term="java_base" scheme="https://github.com/xuegangliu/blog/tags/java-base/"/>
    
  </entry>
  
  <entry>
    <title>测试文档编写</title>
    <link href="https://github.com/xuegangliu/blog/2019/06/03/problem/bug_doc/"/>
    <id>https://github.com/xuegangliu/blog/2019/06/03/problem/bug_doc/</id>
    <published>2019-06-03T13:16:43.000Z</published>
    <updated>2019-06-03T13:16:43.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Bug 描述</strong><br>A clear and concise description of what the bug is.</p><p><strong>复现</strong><br>复现步骤:</p><ol><li>Go to ‘…’</li><li>Click on ‘….’</li><li>Scroll down to ‘….’</li><li>See error</li></ol><p><strong>预期结果</strong><br>A clear and concise description of what you expected to happen.</p><p><strong>截图</strong><br>If applicable, add screenshots to help explain your problem.</p><p><strong>附加信息</strong><br>Add any other context about the problem here.</p><h2 id="单机服务卸流"><a href="#单机服务卸流" class="headerlink" title="单机服务卸流"></a>单机服务卸流</h2><ul><li>漏桶算法</li></ul><p>将流量放入桶中，漏桶同时也按照一定的速率流出，如果流量过快的话就会溢出(漏桶并不会提高流出速率)。溢出的流量则直接丢弃。</p><ul><li>令牌桶算法</li></ul><p>会以一个恒定的速率向固定容量大小桶中放入令牌，当有流量来时则取走一个或多个令牌。当桶中没有令牌则将当前请求丢弃或阻塞。</p><hr><details><br>  <summary>Click to expand</summary><br>  whatever<br></details><details><br>  <summary>Summary</summary><br>  <code><br>  js<br>  const x = 1<br><br>  </code><br></details>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Bug 描述&lt;/strong&gt;&lt;br&gt;A clear and concise description of what the bug is.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;复现&lt;/strong&gt;&lt;br&gt;复现步骤:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Go to ‘…’
      
    
    </summary>
    
      <category term="problem" scheme="https://github.com/xuegangliu/blog/categories/problem/"/>
    
    
      <category term="document" scheme="https://github.com/xuegangliu/blog/tags/document/"/>
    
  </entry>
  
  <entry>
    <title>idea常用的插件</title>
    <link href="https://github.com/xuegangliu/blog/2019/05/30/tools/IDEA_Plugins/"/>
    <id>https://github.com/xuegangliu/blog/2019/05/30/tools/IDEA_Plugins/</id>
    <published>2019-05-30T09:33:43.000Z</published>
    <updated>2019-05-30T09:33:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="idea常用的插件"><a href="#idea常用的插件" class="headerlink" title="idea常用的插件"></a>idea常用的插件</h2><h4 id="插件列表"><a href="#插件列表" class="headerlink" title="插件列表"></a>插件列表</h4><ul><li>[FindBugs-IDEA bug查找]</li><li>[JRebel for IntelliJ 热部署]</li><li>[.ignore git文件忽略]</li><li>[CamelCase 驼峰命名]</li><li>[Lombok plugin javaBean]</li><li>[Material Theme UI 主题]</li><li>[Background image Plus 背景]</li><li>[activate-power-mode 代码编辑屏幕颤抖]</li><li>[Alibaba Java Coding Guidelines 代码规范]</li></ul><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><ul><li><a href="https://www.cnblogs.com/weiguo21/p/tools.html" target="_blank" rel="noopener">blog</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;idea常用的插件&quot;&gt;&lt;a href=&quot;#idea常用的插件&quot; class=&quot;headerlink&quot; title=&quot;idea常用的插件&quot;&gt;&lt;/a&gt;idea常用的插件&lt;/h2&gt;&lt;h4 id=&quot;插件列表&quot;&gt;&lt;a href=&quot;#插件列表&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="tools" scheme="https://github.com/xuegangliu/blog/categories/tools/"/>
    
    
      <category term="IntelliJ_IDEA" scheme="https://github.com/xuegangliu/blog/tags/IntelliJ-IDEA/"/>
    
  </entry>
  
  <entry>
    <title>数据库分库分表</title>
    <link href="https://github.com/xuegangliu/blog/2019/05/08/db/database_bigdata/"/>
    <id>https://github.com/xuegangliu/blog/2019/05/08/db/database_bigdata/</id>
    <published>2019-05-08T09:45:46.000Z</published>
    <updated>2019-05-08T09:45:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>查看了一些blog文档,对分库分表的一些总结</p><h2 id="为什么要分库分表"><a href="#为什么要分库分表" class="headerlink" title="为什么要分库分表"></a>为什么要分库分表</h2><p>查询的数据量大,访问量高,连接数达到库的阈值</p><h3 id="数据库瓶颈"><a href="#数据库瓶颈" class="headerlink" title="数据库瓶颈"></a>数据库瓶颈</h3><ul><li>IO瓶颈</li><li>CPU瓶颈</li></ul><h2 id="分库分表方向"><a href="#分库分表方向" class="headerlink" title="分库分表方向"></a>分库分表方向</h2><p>水平拆分与垂直拆分</p><h4 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h4><ul><li>水平分库拆表:将一个数据库表,拆分到多个库中。</li><li>水平分表:将一个表的数据拆分到多个表中。例如:分月表、年表等</li></ul><h4 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h4><ul><li>垂直分库:将不同的表拆分到不同的库中。按业务类型拆分到不同的库中</li><li>垂直分表:将一个表拆分成多个表,常用的拆分为主表,并与其它拆分表进行关联。主要是单行数据列太多,大多数的列用的很少</li></ul><h3 id="blog链接"><a href="#blog链接" class="headerlink" title="blog链接"></a>blog链接</h3><ul><li><a href="https://mp.weixin.qq.com/s/MMau4yMwxPTFnVEKpDHYpg" target="_blank" rel="noopener">数据库怎么分库分表，垂直？水平？</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;查看了一些blog文档,对分库分表的一些总结&lt;/p&gt;
&lt;h2 id=&quot;为什么要分库分表&quot;&gt;&lt;a href=&quot;#为什么要分库分表&quot; class=&quot;headerlink&quot; title=&quot;为什么要分库分表&quot;&gt;&lt;/a&gt;为什么要分库分表&lt;/h2&gt;&lt;p&gt;查询的数据量大,访问量高,连接数
      
    
    </summary>
    
      <category term="database" scheme="https://github.com/xuegangliu/blog/categories/database/"/>
    
    
      <category term="design" scheme="https://github.com/xuegangliu/blog/tags/design/"/>
    
  </entry>
  
  <entry>
    <title>Java类加载</title>
    <link href="https://github.com/xuegangliu/blog/2019/03/22/java/java_class_base_load/"/>
    <id>https://github.com/xuegangliu/blog/2019/03/22/java/java_class_base_load/</id>
    <published>2019-03-22T10:30:12.000Z</published>
    <updated>2019-03-22T10:30:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、类内部加载顺序"><a href="#一、类内部加载顺序" class="headerlink" title="一、类内部加载顺序"></a>一、类内部加载顺序</h3><ul><li>1.父类static{} 只加载一次</li><li>2.本身static{} 只加载一次</li><li>3.父类{}块 每次</li><li>4.父类构造器 每次</li><li>5.本身{}块 每次</li><li>6.本身构造器 每次</li></ul><details><br>  <summary>类内部加载顺序实例</summary><br>  <a href="https://github.com/xuegangliu/javaBasic/tree/master/jbs-problem/src/main/java/com/lxg/problem/clazz/v1" target="_blank">代码链接</a><br>  <br><br>  <code><br>    package com.lxg.problem.clazz.v1;<br><br>    /<strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong><br>     <em>  Aa     </em> @author xuegangliu<br>     <em>  2019/3/22 14:06<br>     <strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></em>/<br>    public interface Aa {<br><br>        String VERSION=”v1.0.0”;<br><br>        /<strong><br>         <em> say         </em>/<br>        void say();<br><br>        /</strong><br>         <em> main         </em> @param args<br>         <em>/<br>        static void main(String[] args) {<br>            System.out.println(“interface Aa main()”);<br>        }<br>    }<br><br>    package com.lxg.problem.clazz.v1;<br><br>    /<strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong>     </em>  Bb<br>     <em> @author xuegangliu     </em>  2019/3/22 14:06<br>     <strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong>/<br>    public class Bb {<br>        private static String name=”Bb static prop name”;<br>        private String name1;<br><br>        static {<br>            System.out.println(“Bb static{}”);<br>        }<br><br>        {<br>            System.out.println(“Bb {}”);<br>        }<br><br>        public Bb(){<br>            System.out.println(“Bb()”);<br>        }<br><br>        public Bb(String name1){<br>            this.name1=name1;<br>            System.out.println(“Bb(String name1)”);<br>        }<br><br>        public void talk(){<br>            System.out.println(“b.talk(){}”);<br>        }<br><br>        public static void main(String[] args) {<br>            System.out.println(“———-Bb main()”);<br>            Bb t=new Bb();<br>            System.out.println(t.name1);<br>            t.talk();<br>        }<br>    }<br><br>    package com.lxg.problem.clazz.v1;<br><br><br>    /<strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong><br>     <em>  Cc     </em> @author xuegangliu<br>     <em>  2019/3/22 14:06<br>     <strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></em>/<br>    public  class Cc extends Bb implements Aa {<br><br>        private static String name = “Cc”;<br><br>        private String name1=”c”;<br><br>        static {<br>            System.out.println(“Cc static{}”+VERSION);<br>        }<br><br>        {<br>            System.out.println(“Cc {}”);<br>        }<br><br>        public Cc(){<br>            System.out.println(“Cc()”);<br>        }<br><br>        public Cc(String name1){<br>            this.name1=name1;<br>            System.out.println(“Cc(String name1)”);<br>        }<br><br>        public static void ok(){<br>            System.out.println(“Cc static Cc.ok()”);<br>        }<br><br>        @Override<br>        public void say() {<br>            System.out.println(“c.say()”);<br>        }<br><br>        @Override<br>        public void talk(){<br>            super.talk();<br>            System.out.println(“c.talk(){}”);<br>        }<br><br>        public static void main(String[] args) {<br>            // 1.父类的static{}只加载一次     Bb static{}<br>            // 2.当前类的static{}只加载一次   Cc static{}v1.0.0<br>            // 3.当前方法           —–Cc main()<br>            System.out.println(“===============Cc main()”);<br><br>            // 4.父类 {}块          Bb {}<br>            // 5.父类 构造器         Bb()<br>            // 6.当前类 {}块         Cc {}<br>            // 7.当前类 构造器       Cc()<br>            Cc c=new Cc();<br>            System.out.println(c.name1);<br>            c.say();<br>            c.talk();<br>            System.out.println(“===============”);<br>            Cc c1=new Cc();<br>        }<br>    }<br><br><br>  </code><br></details><h3 id="二、Java-基本数据类型"><a href="#二、Java-基本数据类型" class="headerlink" title="二、Java 基本数据类型"></a>二、Java 基本数据类型</h3><ul><li>内置数据类型<ul><li>(byte(8位有符号,java.lang.Byte)</li><li>short(16位有符号,java.lang.Short)</li><li>int(32位有符号,java.lang.Integer)</li><li>long(64位有符号,java.lang.Long)</li><li>float(32位,java.lang.Float)</li><li>double(64位,java.lang.Double)</li><li>boolean(1位)</li><li>char(单一的 16 位 Unicode 字符,java.lang.Character)</li><li>void(java.lang.Void)</li></ul></li></ul><h3 id="三、Java数据结构（集合框架）"><a href="#三、Java数据结构（集合框架）" class="headerlink" title="三、Java数据结构（集合框架）"></a>三、Java数据结构（集合框架）</h3><ul><li>接口:<ul><li>java.lang.Iterable、java.util.Collection|java.util.concurrent.Callable、java.util.concurrent.Executor</li><li>java.util.List</li><li>java.util.Queue（单向队列）、java.util.Deque(双向队列)|java.util.concurrent.BlockingQueue,java.util.concurrent.BlockingDeque、java.util.concurrent.TransferQueue(1.7)</li><li>Set、SortedSet、NavigableSet</li><li>java.util.Map、java.util.SortedMap、java.util.NavigableMap|java.util.concurrent.ConcurrentMap、java.util.concurrent.ConcurrentNavigableMap</li></ul></li><li>数组：java.util.Vector[同步]、java.util.ArrayList、java.util.LinkedList|java.util.concurrent.CopyOnWriteArrayList</li><li>栈：java.util.Stack 数据入栈和出栈的时间复杂度都为O(1)[Deque接口方法可以实现stack的方法，可以代替stack]</li><li>队列：java.util.PriorityQueue、java.util.ArrayDeque<ul><li>不阻塞队列 ：java.util.PriorityQueue、java.util.concurrent.ConcurrentLinkedQueue</li><li>阻塞队列：java.util.concurrent.ArrayBlockingQueue、java.util.concurrent.DelayQueue、java.util.concurrent.LinkedBlockingDeque、java.util.concurrent.LinkedBlockingQueue、java.util.concurrent.PriorityBlockingQueue、java.util.concurrent.SynchronousQueue</li></ul></li><li>Set：java.util.HashSet、java.util.LinkedHashSet、java.util.TreeSet|java.util.concurrent.ConcurrentSkipListSet、java.util.concurrent.CopyOnWriteArraySet</li><li>Map：java.util.HashMap、java.util.LinkedHashMap、java.util.IdentityHashMap、java.util.TreeMap、java.util.WeakHashMap、java.util.Hashtable[同步]、java.util.Properties[同步]|java.util.concurrent.ConcurrentHashMap、java.util.concurrent.ConcurrentSkipListMap</li><li>工具类：java.util.Arrays、java.util.Collections|java.util.concurrent.Executors</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、类内部加载顺序&quot;&gt;&lt;a href=&quot;#一、类内部加载顺序&quot; class=&quot;headerlink&quot; title=&quot;一、类内部加载顺序&quot;&gt;&lt;/a&gt;一、类内部加载顺序&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;1.父类static{} 只加载一次&lt;/li&gt;
&lt;li&gt;2.本身stat
      
    
    </summary>
    
      <category term="java" scheme="https://github.com/xuegangliu/blog/categories/java/"/>
    
    
      <category term="knowledge" scheme="https://github.com/xuegangliu/blog/tags/knowledge/"/>
    
      <category term="java_base" scheme="https://github.com/xuegangliu/blog/tags/java-base/"/>
    
      <category term="skills" scheme="https://github.com/xuegangliu/blog/tags/skills/"/>
    
  </entry>
  
  <entry>
    <title>设计模式原则</title>
    <link href="https://github.com/xuegangliu/blog/2019/01/10/idea/design-principles/"/>
    <id>https://github.com/xuegangliu/blog/2019/01/10/idea/design-principles/</id>
    <published>2019-01-10T10:36:25.000Z</published>
    <updated>2019-01-10T10:36:25.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面向对象原则"><a href="#面向对象原则" class="headerlink" title="面向对象原则"></a>面向对象原则</h2><p>Java编程最基本的原则就是要追求高内聚和低耦合的解决方案和代码模块设计<br>SOLID原则：S.O.L.I.D是面向对象设计和编程(OOD&amp;OOP)中几个重要编码原则(Programming Priciple)的首字母缩写。</p><table><thead><tr><th>English</th><th>中文</th></tr></thead><tbody><tr><td>SRP The Single Responsibility Principle</td><td>单一责任原则</td></tr><tr><td>OCP The Open Closed Principle</td><td>开放封闭原则</td></tr><tr><td>LSP The Liskov Substitution Principle</td><td>里氏替换原则</td></tr><tr><td>ISP The Interface Segregation Principle</td><td>接口分离原则</td></tr><tr><td>DIP The Dependency Inversion Principle</td><td>依赖倒置原则</td></tr></tbody></table><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul><li><ol><li>单一责任原则（SRP）[单类单功能]<br> 当需要修改某个类的时候原因有且只有一个。换句话说就是让一个类只做一种类型责任，当这个类需要承当其他类型的责任的时候，就需要分解这个类。 类被修改的几率很大，因此应该专注于单一的功能。如果你把多个功能放在同一个类中，功能之间就形成了关联，改变其中一个功能，有可能中止另一个功能，这时就需要新一轮的测试来避免可能出现的问题，非常耗时耗力。</li></ol></li><li><ol start="2"><li>开放封闭原则（OCP）[新扩展，旧不变]<br>软件实体应该是可扩展，而不可修改的。也就是说，对扩展是开放的，而对修改是封闭的。这个原则是诸多面向对象编程原则中最抽象、最难理解的一个。<ul><li>(1)通过增加代码来扩展功能，而不是修改已经存在的代码。</li><li>(2)若客户模块和服务模块遵循同一个接口来设计，则客户模块可以不关心服务模块的类型，服务模块可以方便扩展服务(代码)。</li><li>(3)OCP支持替换的服务，而不用修改客户模块。</li></ul></li></ol></li><li><ol start="3"><li>里氏替换原则（LSP）<br>当一个子类的实例应该能够替换任何其超类的实例时，它们之间才具有is-A关系<br>客户模块不应关心服务模块的是如何工作的；同样的接口模块之间，可以在不知道服务模块代码的情况下，进行替换。即接口或父类出现的地方，实现接口的类或子类可以代入。</li></ol></li><li><ol start="4"><li>接口分离原则（ISP）[解决多余]<br>不能强迫用户去依赖那些他们不使用的接口。换句话说，使用多个专门的接口比使用单一的总接口总要好。<br>客户模块不应该依赖大的接口，应该裁减为小的接口给客户模块使用，以减少依赖性。如Java中一个类实现多个接口，不同的接口给不用的客户模块使用，而不是提供给客户模块一个大的接口。</li></ol></li><li><ol start="5"><li>依赖注入或倒置原则（DIP）<ul><li><ol><li>高层模块不应该依赖于低层模块，二者都应该依赖于抽象 </li></ol></li><li><ol start="2"><li>抽象不应该依赖于细节，细节应该依赖于抽象<br>这个设计原则的亮点在于任何被DI框架注入的类很容易用mock对象进行测试和维护，因为对象创建代码集中在框架中，客户端代码也不混乱。有很多方式可以实现依赖倒置，比如像AspectJ等的AOP（Aspect Oriented programming）框架使用的字节码技术，或Spring框架使用的代理等。</li></ol></li><li>(1).高层模块不要依赖低层模块；</li><li>(2).高层和低层模块都要依赖于抽象；</li><li>(3).抽象不要依赖于具体实现； </li><li>(4).具体实现要依赖于抽象；</li><li>(5).抽象和接口使模块之间的依赖分离。</li></ul></li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;面向对象原则&quot;&gt;&lt;a href=&quot;#面向对象原则&quot; class=&quot;headerlink&quot; title=&quot;面向对象原则&quot;&gt;&lt;/a&gt;面向对象原则&lt;/h2&gt;&lt;p&gt;Java编程最基本的原则就是要追求高内聚和低耦合的解决方案和代码模块设计&lt;br&gt;SOLID原则：S.O.L.
      
    
    </summary>
    
      <category term="idea" scheme="https://github.com/xuegangliu/blog/categories/idea/"/>
    
    
      <category term="knowledge" scheme="https://github.com/xuegangliu/blog/tags/knowledge/"/>
    
      <category term="design_patterns" scheme="https://github.com/xuegangliu/blog/tags/design-patterns/"/>
    
  </entry>
  
  <entry>
    <title>github_emoji</title>
    <link href="https://github.com/xuegangliu/blog/2019/01/10/tools/github_emoji/"/>
    <id>https://github.com/xuegangliu/blog/2019/01/10/tools/github_emoji/</id>
    <published>2019-01-10T10:36:25.000Z</published>
    <updated>2019-01-10T10:36:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="github-emoji"><a href="#github-emoji" class="headerlink" title="github_emoji"></a>github_emoji</h1><p>emoji图标使用</p><h2 id="emoji-指南"><a href="#emoji-指南" class="headerlink" title="emoji 指南"></a>emoji 指南</h2><table><thead><tr><th style="text-align:left">emoji</th><th style="text-align:left">emoji 代码</th><th style="text-align:left">commit 说明</th></tr></thead><tbody><tr><td style="text-align:left">:tada: (庆祝)</td><td style="text-align:left"><code>:tada:</code></td><td style="text-align:left">初次提交</td></tr><tr><td style="text-align:left">:sparkles: (火花)</td><td style="text-align:left"><code>:sparkles:</code></td><td style="text-align:left">引入新功能</td></tr><tr><td style="text-align:left">:bookmark: (书签)</td><td style="text-align:left"><code>:bookmark:</code></td><td style="text-align:left">发行/版本标签</td></tr><tr><td style="text-align:left">:bug: (bug)</td><td style="text-align:left"><code>:bug:</code></td><td style="text-align:left">修复 bug</td></tr><tr><td style="text-align:left">:ambulance: (急救车)</td><td style="text-align:left"><code>:ambulance:</code></td><td style="text-align:left">重要补丁</td></tr><tr><td style="text-align:left">:globe_with_meridians: (地球)</td><td style="text-align:left"><code>:globe_with_meridians:</code></td><td style="text-align:left">国际化与本地化</td></tr><tr><td style="text-align:left">:lipstick: (口红)</td><td style="text-align:left"><code>:lipstick:</code></td><td style="text-align:left">更新 UI 和样式文件</td></tr><tr><td style="text-align:left">:rotating_light: (警车灯)</td><td style="text-align:left"><code>:rotating_light:</code></td><td style="text-align:left">移除 linter 警告</td></tr><tr><td style="text-align:left">:wrench: (扳手)</td><td style="text-align:left"><code>:wrench:</code></td><td style="text-align:left">修改配置文件</td></tr><tr><td style="text-align:left">:heavy_plus_sign: (加号)</td><td style="text-align:left"><code>:heavy_plus_sign:</code></td><td style="text-align:left">增加一个依赖</td></tr><tr><td style="text-align:left">:heavy_minus_sign: (减号)</td><td style="text-align:left"><code>:heavy_minus_sign:</code></td><td style="text-align:left">减少一个依赖</td></tr><tr><td style="text-align:left">:arrow_up: (上升箭头)</td><td style="text-align:left"><code>:arrow_up:</code></td><td style="text-align:left">升级依赖</td></tr><tr><td style="text-align:left">:arrow_down: (下降箭头)</td><td style="text-align:left"><code>:arrow_down:</code></td><td style="text-align:left">降级依赖</td></tr><tr><td style="text-align:left">:zap: (闪电)<br>:racehorse: (赛马)</td><td style="text-align:left"><code>:zap:</code><br><code>:racehorse:</code></td><td style="text-align:left">提升性能</td></tr><tr><td style="text-align:left">:chart_with_upwards_trend: (上升趋势图)</td><td style="text-align:left"><code>:chart_with_upwards_trend:</code></td><td style="text-align:left">添加分析或跟踪代码</td></tr><tr><td style="text-align:left">:rocket: (火箭)</td><td style="text-align:left"><code>:rocket:</code></td><td style="text-align:left">部署功能</td></tr><tr><td style="text-align:left">:white_check_mark: (白色复选框)</td><td style="text-align:left"><code>:white_check_mark:</code></td><td style="text-align:left">增加测试</td></tr><tr><td style="text-align:left">:memo: (备忘录)</td><td style="text-align:left"><code>:memo:</code></td><td style="text-align:left">撰写文档</td></tr><tr><td style="text-align:left">:hammer: (锤子)</td><td style="text-align:left"><code>:hammer:</code></td><td style="text-align:left">重大重构</td></tr><tr><td style="text-align:left">:art: (调色板)</td><td style="text-align:left"><code>:art:</code></td><td style="text-align:left">改进代码结构/代码格式</td></tr><tr><td style="text-align:left">:fire: (火焰)</td><td style="text-align:left"><code>:fire:</code></td><td style="text-align:left">移除代码或文件</td></tr><tr><td style="text-align:left">:pencil2: (铅笔)</td><td style="text-align:left"><code>:pencil2:</code></td><td style="text-align:left">修复 typo</td></tr><tr><td style="text-align:left">:construction: (施工)</td><td style="text-align:left"><code>:construction:</code></td><td style="text-align:left">工作进行中</td></tr><tr><td style="text-align:left">:construction_worker: (工人)</td><td style="text-align:left"><code>:construction_worker:</code></td><td style="text-align:left">添加 CI 构建系统</td></tr><tr><td style="text-align:left">:green_heart: (绿心)</td><td style="text-align:left"><code>:green_heart:</code></td><td style="text-align:left">修复 CI 构建问题</td></tr><tr><td style="text-align:left">:lock: (锁)</td><td style="text-align:left"><code>:lock:</code></td><td style="text-align:left">修复安全问题</td></tr><tr><td style="text-align:left">:whale: (鲸鱼)</td><td style="text-align:left"><code>:whale:</code></td><td style="text-align:left">Docker 相关工作</td></tr><tr><td style="text-align:left">:apple: (苹果)</td><td style="text-align:left"><code>:apple:</code></td><td style="text-align:left">修复 macOS 下的问题</td></tr><tr><td style="text-align:left">:penguin: (企鹅)</td><td style="text-align:left"><code>:penguin:</code></td><td style="text-align:left">修复 Linux 下的问题</td></tr><tr><td style="text-align:left">:checkered_flag: (旗帜)</td><td style="text-align:left"><code>:checked_flag:</code></td><td style="text-align:left">修复 Windows 下的问题</td></tr></tbody></table><h2 id="简单常用emoji"><a href="#简单常用emoji" class="headerlink" title="简单常用emoji"></a>简单常用emoji</h2><p><a href="https://segmentfault.com/a/1190000009649780#articleHeader6" target="_blank" rel="noopener">emoji分类</a><br>简单</p><ul><li>:ok:</li><li>:up:</li><li>:cool:</li><li>:new:</li><li>:top:</li><li>:red_circle:</li><li>:white_circle:</li><li>:black_circle:</li><li>:link:</li><li>:100:</li><li>:o:</li><li>:x:</li><li>:copyright:</li><li>:tm:</li><li>:on:</li><li>:o2:</li><li>:a:</li><li>:ab:</li><li>:recycle:</li><li>:b:</li><li>:vs:</li><li>:sos:</li><li>:id:</li><li>:m:</li><li>:mens:</li><li>:free:</li><li>:repeat:</li><li>:hash:</li><li>:cn:</li><li>:smile:</li><li>:rage:</li><li>:shit:</li><li>:v:</li><li>:heart:</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;github-emoji&quot;&gt;&lt;a href=&quot;#github-emoji&quot; class=&quot;headerlink&quot; title=&quot;github_emoji&quot;&gt;&lt;/a&gt;github_emoji&lt;/h1&gt;&lt;p&gt;emoji图标使用&lt;/p&gt;
&lt;h2 id=&quot;emoji-指南
      
    
    </summary>
    
      <category term="tools" scheme="https://github.com/xuegangliu/blog/categories/tools/"/>
    
    
      <category term="emoji" scheme="https://github.com/xuegangliu/blog/tags/emoji/"/>
    
      <category term="github" scheme="https://github.com/xuegangliu/blog/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>travis构建配置</title>
    <link href="https://github.com/xuegangliu/blog/2019/01/08/tools/travis_build/"/>
    <id>https://github.com/xuegangliu/blog/2019/01/08/tools/travis_build/</id>
    <published>2019-01-08T16:52:37.000Z</published>
    <updated>2019-01-08T16:52:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="travis"><a href="#travis" class="headerlink" title="travis"></a>travis</h1><p>构建github代码库中的项目</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p><code>travis.yml</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># 选择项目的语言及版本</span><br><span class="line">language: python</span><br><span class="line">python:</span><br><span class="line">  - &quot;2.7&quot;</span><br><span class="line"></span><br><span class="line"># 打包之前的操作</span><br><span class="line">before_install: &quot;sudo apt-get update&quot;</span><br><span class="line"># 依赖安装等</span><br><span class="line">install: &quot;pip install -q -r requirements.txt --use-mirrors&quot;</span><br><span class="line"></span><br><span class="line"># 构建</span><br><span class="line">script: make html</span><br><span class="line"></span><br><span class="line"># 限制项目分支</span><br><span class="line">branches:</span><br><span class="line">  only:</span><br><span class="line">    - mybranch</span><br><span class="line"></span><br><span class="line">## 构建完成之后的命令</span><br><span class="line">after_success:</span><br><span class="line">    &quot;find ./make/output -type f -exec curl --ftp-create-dirs -u $FTP_USER:$FTP_PASSWORD -T &#123;&#125; ftp://123.45.67.89/myproject/&#123;&#125; \\;&quot;</span><br><span class="line"></span><br><span class="line">#环境变量</span><br><span class="line">env:</span><br><span class="line">  global:</span><br><span class="line">    - &quot;FTP_USER=myusername&quot;</span><br><span class="line">    - &quot;FTP_PASSWORD=mypassword&quot;</span><br><span class="line"></span><br><span class="line"># 邮件通知</span><br><span class="line">notifications:</span><br><span class="line">  email:</span><br><span class="line">    recipients:</span><br><span class="line">        - 1453860636@qq.com</span><br><span class="line">    on_success: change</span><br><span class="line">    on_failure: always</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;travis&quot;&gt;&lt;a href=&quot;#travis&quot; class=&quot;headerlink&quot; title=&quot;travis&quot;&gt;&lt;/a&gt;travis&lt;/h1&gt;&lt;p&gt;构建github代码库中的项目&lt;/p&gt;
&lt;h2 id=&quot;配置&quot;&gt;&lt;a href=&quot;#配置&quot; class=&quot;h
      
    
    </summary>
    
      <category term="tools" scheme="https://github.com/xuegangliu/blog/categories/tools/"/>
    
    
      <category term="travis" scheme="https://github.com/xuegangliu/blog/tags/travis/"/>
    
  </entry>
  
  <entry>
    <title>和融通支付</title>
    <link href="https://github.com/xuegangliu/blog/2018/11/26/work/hrtpayment/"/>
    <id>https://github.com/xuegangliu/blog/2018/11/26/work/hrtpayment/</id>
    <published>2018-11-26T09:00:00.000Z</published>
    <updated>2018-11-26T09:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>18年末的时候,加入了和融通支付,对于我来说,这是一个新的业务方向,之前没有接触过支付业务,需要多学习</p><h4 id="参与项目"><a href="#参与项目" class="headerlink" title="参与项目"></a>参与项目</h4><ul><li>商户支付业务管理平台<ul><li>代理商</li><li>商户</li></ul></li></ul><h4 id="支付业务了解-blog"><a href="#支付业务了解-blog" class="headerlink" title="支付业务了解-blog"></a>支付业务了解-blog</h4><ul><li><a href="https://mp.weixin.qq.com/s/wvFd6Vp-yuEHUqqZ_zIGlQ" target="_blank" rel="noopener">第三方支付</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;18年末的时候,加入了和融通支付,对于我来说,这是一个新的业务方向,之前没有接触过支付业务,需要多学习&lt;/p&gt;
&lt;h4 id=&quot;参与项目&quot;&gt;&lt;a href=&quot;#参与项目&quot; class=&quot;headerlink&quot; title=&quot;参与项目&quot;&gt;&lt;/a&gt;参与项目&lt;/h4&gt;&lt;ul&gt;
&lt;
      
    
    </summary>
    
      <category term="work" scheme="https://github.com/xuegangliu/blog/categories/work/"/>
    
    
      <category term="pay" scheme="https://github.com/xuegangliu/blog/tags/pay/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu基础命令</title>
    <link href="https://github.com/xuegangliu/blog/2018/11/09/linux/shell_base/"/>
    <id>https://github.com/xuegangliu/blog/2018/11/09/linux/shell_base/</id>
    <published>2018-11-09T15:28:01.000Z</published>
    <updated>2018-11-09T15:28:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p><img src="dir1.png" alt="目录结构1"><br><img src="dir2.png" alt="目录结构2"><br><img src="dir3.png" alt="目录结构2"><br><img src="dir4.png" alt="目录结构2"></p><h2 id="软件包管理"><a href="#软件包管理" class="headerlink" title="软件包管理"></a>软件包管理</h2><p>Ubuntu更新软件时的软件源配置文件是/etc/apt/sources.list。<br>ubuntu的官方软件源分为4类：</p><ul><li>main：这个是官方维护的基本库。</li><li>restricted：官方维护的其他自由软件。</li><li>universe：自由软件，但是官方不维护。</li><li>multiverse：非自由软件，官方不维护。</li></ul><p>apt<br>apt是一套完整的软件包管理方案。除了最常用apt-get之外，还包括了一系列的客户端和服务器软件。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-cache search gstreamer 搜索名字中包含gstreamer的软件包。</span><br><span class="line">sudo add-apt-repository ppa:tualatrix/ppa添加新的软件源。</span><br></pre></td></tr></table></figure></p><h3 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令"></a>安装命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo  apt-get install foo</span><br><span class="line">dpkg -i *.deb</span><br><span class="line">wget http://*</span><br></pre></td></tr></table></figure><h3 id="卸载命令"><a href="#卸载命令" class="headerlink" title="卸载命令"></a>卸载命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get --purge remove foo</span><br><span class="line">sudo  apt-get remove  foo</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录结构&quot;&gt;&lt;a href=&quot;#目录结构&quot; class=&quot;headerlink&quot; title=&quot;目录结构&quot;&gt;&lt;/a&gt;目录结构&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;dir1.png&quot; alt=&quot;目录结构1&quot;&gt;&lt;br&gt;&lt;img src=&quot;dir2.png&quot; alt=&quot;目
      
    
    </summary>
    
      <category term="linux" scheme="https://github.com/xuegangliu/blog/categories/linux/"/>
    
    
      <category term="shell" scheme="https://github.com/xuegangliu/blog/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu结构</title>
    <link href="https://github.com/xuegangliu/blog/2018/11/09/linux/ubuntu_base/"/>
    <id>https://github.com/xuegangliu/blog/2018/11/09/linux/ubuntu_base/</id>
    <published>2018-11-09T15:28:01.000Z</published>
    <updated>2018-11-09T15:28:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p><img src="/book/images/linux/dir1.png" alt="目录结构1"><br><img src="/book/images/linux/dir2.png" alt="目录结构2"><br><img src="/book/images/linux/dir3.png" alt="目录结构2"><br><img src="/book/images/linux/dir4.png" alt="目录结构2"></p><h2 id="软件包管理"><a href="#软件包管理" class="headerlink" title="软件包管理"></a>软件包管理</h2><p>Ubuntu更新软件时的软件源配置文件是/etc/apt/sources.list。<br>ubuntu的官方软件源分为4类：</p><ul><li>main：这个是官方维护的基本库。</li><li>restricted：官方维护的其他自由软件。</li><li>universe：自由软件，但是官方不维护。</li><li>multiverse：非自由软件，官方不维护。</li></ul><p>apt<br>apt是一套完整的软件包管理方案。除了最常用apt-get之外，还包括了一系列的客户端和服务器软件。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-cache search gstreamer 搜索名字中包含gstreamer的软件包。</span><br><span class="line">sudo add-apt-repository ppa:tualatrix/ppa添加新的软件源。</span><br></pre></td></tr></table></figure></p><h3 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令"></a>安装命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo  apt-get install foo</span><br><span class="line">dpkg -i *.deb</span><br><span class="line">wget http://*</span><br></pre></td></tr></table></figure><h3 id="卸载命令"><a href="#卸载命令" class="headerlink" title="卸载命令"></a>卸载命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get --purge remove foo</span><br><span class="line">sudo  apt-get remove  foo</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录结构&quot;&gt;&lt;a href=&quot;#目录结构&quot; class=&quot;headerlink&quot; title=&quot;目录结构&quot;&gt;&lt;/a&gt;目录结构&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/book/images/linux/dir1.png&quot; alt=&quot;目录结构1&quot;&gt;&lt;br&gt;&lt;img sr
      
    
    </summary>
    
      <category term="linux" scheme="https://github.com/xuegangliu/blog/categories/linux/"/>
    
    
      <category term="ubuntu" scheme="https://github.com/xuegangliu/blog/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>JVM性能调优</title>
    <link href="https://github.com/xuegangliu/blog/2018/11/09/java/jvm_tuning/"/>
    <id>https://github.com/xuegangliu/blog/2018/11/09/java/jvm_tuning/</id>
    <published>2018-11-09T15:19:01.000Z</published>
    <updated>2018-11-09T15:19:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM性能调优"><a href="#JVM性能调优" class="headerlink" title="JVM性能调优"></a>JVM性能调优</h1><h2 id="一、JVM内存模型及垃圾收集算法"><a href="#一、JVM内存模型及垃圾收集算法" class="headerlink" title="一、JVM内存模型及垃圾收集算法"></a>一、JVM内存模型及垃圾收集算法</h2><h3 id="1-根据Java虚拟机规范，JVM将内存划分为："><a href="#1-根据Java虚拟机规范，JVM将内存划分为：" class="headerlink" title="1.根据Java虚拟机规范，JVM将内存划分为："></a>1.根据Java虚拟机规范，JVM将内存划分为：</h3><ul><li>New（年轻代)[启动分配堆内存]（-Xmx:3G）<br>  年轻代用来存放JVM刚分配的Java对象<ul><li>Eden：Eden用来存放JVM刚分配的对象</li><li>Survivor1</li><li>Survivro2：两个Survivor空间一样大，当Eden中的对象经过垃圾回收没有被回收掉时，会在两个Survivor之间来回Copy，当满足某个条件，比如Copy次数，就会被Copy到Tenured。显然，Survivor只是增加了对象在年轻代中的逗留时间，增加了被垃圾回收的可能性。</li></ul></li><li>Tenured（年老代）[启动分配堆内存]（-Xmx:3G）</li><li>永久代（Perm）[JVM分配内存] （-XX:PermSize -XX:MaxPermSize）</li></ul><h3 id="2-垃圾回收算法"><a href="#2-垃圾回收算法" class="headerlink" title="2.垃圾回收算法"></a>2.垃圾回收算法</h3><p>垃圾回收算法可以分为三类，都基于标记-清除（复制）算法：</p><ul><li>Serial算法（单线程）</li><li>并行算法</li><li>并发算法</li></ul><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://blog.csdn.net/chen77716/article/details/5695893" target="_blank" rel="noopener">JVM性能调优</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JVM性能调优&quot;&gt;&lt;a href=&quot;#JVM性能调优&quot; class=&quot;headerlink&quot; title=&quot;JVM性能调优&quot;&gt;&lt;/a&gt;JVM性能调优&lt;/h1&gt;&lt;h2 id=&quot;一、JVM内存模型及垃圾收集算法&quot;&gt;&lt;a href=&quot;#一、JVM内存模型及垃圾收集算法&quot;
      
    
    </summary>
    
      <category term="java" scheme="https://github.com/xuegangliu/blog/categories/java/"/>
    
    
      <category term="knowledge" scheme="https://github.com/xuegangliu/blog/tags/knowledge/"/>
    
      <category term="java_jvm" scheme="https://github.com/xuegangliu/blog/tags/java-jvm/"/>
    
  </entry>
  
  <entry>
    <title>JVM命令工具</title>
    <link href="https://github.com/xuegangliu/blog/2018/02/09/java/jvm_tools_cmd/"/>
    <id>https://github.com/xuegangliu/blog/2018/02/09/java/jvm_tools_cmd/</id>
    <published>2018-02-09T15:14:30.000Z</published>
    <updated>2018-03-02T11:25:33.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="命令工具"><a href="#命令工具" class="headerlink" title="命令工具"></a>命令工具</h1><ul><li>jps：进程列表</li><li>jinfo：进程配置信息</li><li>jstat：内存配置信息</li><li>jstack：堆栈信息</li><li>jmap：dump堆内存快照</li><li>jhat：和jmap配合使用，分析堆内存快照文件</li></ul><h2 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h2><pre><code>-q 只输出LVMID，同进程pid-m 输出JVM启动时传给主类main()的参数。-l 输出主类全名。如果进程执行的是jar包，则输出包名。-v 输出JVM启动时JVM参数。</code></pre><p><img src="/book/images/java/jps.png" alt="jps"></p><h2 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h2><pre><code>-flag name 打印给定name对应的命令行参数值。-flag [+|-]name 更改boolean类型的命令行参数值-flag name=value 更改name对应的命令行参数值为value。-flags 打印传给JVM的命令参数值。-sysprops 打印系统属性值。</code></pre><p><img src="/book/images/java/jinfo.png" alt="jps"></p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://blog.csdn.net/dream361/article/details/77975381" target="_blank" rel="noopener">介绍</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;命令工具&quot;&gt;&lt;a href=&quot;#命令工具&quot; class=&quot;headerlink&quot; title=&quot;命令工具&quot;&gt;&lt;/a&gt;命令工具&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;jps：进程列表&lt;/li&gt;
&lt;li&gt;jinfo：进程配置信息&lt;/li&gt;
&lt;li&gt;jstat：内存配置信息&lt;/li
      
    
    </summary>
    
      <category term="java" scheme="https://github.com/xuegangliu/blog/categories/java/"/>
    
    
      <category term="java_jvm_cmd" scheme="https://github.com/xuegangliu/blog/tags/java-jvm-cmd/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat调优</title>
    <link href="https://github.com/xuegangliu/blog/2018/01/09/server/tomcat_tuning/"/>
    <id>https://github.com/xuegangliu/blog/2018/01/09/server/tomcat_tuning/</id>
    <published>2018-01-09T15:16:45.000Z</published>
    <updated>2018-01-09T15:16:45.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-tomcat内存配置"><a href="#1-tomcat内存配置" class="headerlink" title="1.tomcat内存配置"></a>1.tomcat内存配置</h2><ul><li><p>案例：由于服务启动后，会有大量的excel文件进行生成，以及大量的定时任务在跑。导致服务抛出堆溢出。</p></li><li><p>解决办法：设置服务JVM参数</p><blockquote><p>JAVA_OPTS=’-Xms【初始化内存大小】 -Xmx【可以使用的最大内存】’<br>最大值设置为可用内存的最大值的80%</p></blockquote></li></ul><h2 id="2-tomcat线程优化"><a href="#2-tomcat线程优化" class="headerlink" title="2.tomcat线程优化"></a>2.tomcat线程优化</h2><h3 id="1、JDK内存优化"><a href="#1、JDK内存优化" class="headerlink" title="1、JDK内存优化"></a>1、JDK内存优化</h3><h3 id="2、连接器优化"><a href="#2、连接器优化" class="headerlink" title="2、连接器优化"></a>2、连接器优化</h3><pre><code>`maxThreads`：Tomcat使用线程来处理接收的每个请求。这个值表示Tomcat可创建的最大的线程数。默认值150。`acceptCount`：指定当所有可以使用的处理请求的线程数都被使用时，可以放到处理队列中的请求数，超过这个数的请求将不予处理。默认值10。`minSpareThreads`：Tomcat初始化时创建的线程数。默认值25。`maxSpareThreads`：一旦创建的线程超过这个值，Tomcat就会关闭不再需要的socket线程。默认值75。`enableLookups`：是否反查域名，默认值为true。为了提高处理能力，应设置为falseconnnectionTimeout：网络连接超时，默认值60000，单位：毫秒。设置为0表示永不超时，这样设置有隐患的。通常可设置为30000毫秒。`maxKeepAliveRequests`：保持请求数量，默认值100。`bufferSize`：输入流缓冲大小，默认值2048 bytes。`compression`：压缩传输，取值on/off/force，默认值off。其中和最大连接数相关的参数为maxThreads和acceptCount。如果要加大并发连接数，应同时加大这两个参数。web server允许的最大连接数还受制于*作系统的内核参数设置，通常Windows是2000个左右，Linux是1000个左右。</code></pre><h3 id="3-tomcat中如何禁止和允许列目录下的文件"><a href="#3-tomcat中如何禁止和允许列目录下的文件" class="headerlink" title="3.tomcat中如何禁止和允许列目录下的文件"></a>3.tomcat中如何禁止和允许列目录下的文件</h3><h3 id="4-tomcat中如何禁止和允许主机或IP地址访问"><a href="#4-tomcat中如何禁止和允许主机或IP地址访问" class="headerlink" title="4.tomcat中如何禁止和允许主机或IP地址访问"></a>4.tomcat中如何禁止和允许主机或IP地址访问</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-tomcat内存配置&quot;&gt;&lt;a href=&quot;#1-tomcat内存配置&quot; class=&quot;headerlink&quot; title=&quot;1.tomcat内存配置&quot;&gt;&lt;/a&gt;1.tomcat内存配置&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;案例：由于服务启动后，会有大量的excel
      
    
    </summary>
    
      <category term="server" scheme="https://github.com/xuegangliu/blog/categories/server/"/>
    
    
      <category term="tomcat" scheme="https://github.com/xuegangliu/blog/tags/tomcat/"/>
    
  </entry>
  
  <entry>
    <title>JVM参数</title>
    <link href="https://github.com/xuegangliu/blog/2018/01/09/java/jvm_params/"/>
    <id>https://github.com/xuegangliu/blog/2018/01/09/java/jvm_params/</id>
    <published>2018-01-09T10:13:23.000Z</published>
    <updated>2018-01-09T10:13:23.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jvm参数"><a href="#jvm参数" class="headerlink" title="jvm参数"></a>jvm参数</h1><h2 id="JVM-类型以及编译器模式"><a href="#JVM-类型以及编译器模式" class="headerlink" title="JVM 类型以及编译器模式"></a>JVM 类型以及编译器模式</h2><ul><li>类型：-server and -client</li><li>版本信息：-version and -showversion</li><li>编译器模式：-Xint（解释模式 执行所有【慢】）, -Xcomp（JIT 编译器少部分功能）, 和 -    Xmixed（混合模式）</li><li>参数分类和即时（JIT）编译器诊断</li><li>标准参数<ul><li>X参数</li><li>XX参数<ul><li>-XX:+PrintCompilation 输出一些关于从字节码转化成本地代码的编译过程</li><li>-XX:+CITime JVM 关闭时得到各种编译的统计信息</li><li>-XX:+PrintFlagsFinal and -XX:+PrintFlagsInitial 打印所有 XX 参数及值</li><li>-XX:+PrintCommandLineFlags打印出那些已经被用户或者 JVM 设置过的详细的 XX 参数的名称和值 </li><li>-XX:+HeapDumpOnOutOfMemoryError and -XX:HeapDumpPath 堆内存快照</li><li>-XX:OnOutOfMemoryError 当内存溢发生时，我们甚至可以可以执行一些指令</li><li>-XX:PermSize and -XX:MaxPermSize 永久代堆内存</li><li>-XX:InitialCodeCacheSize and -XX:ReservedCodeCacheSize代码缓存</li><li>-XX:+UseCodeCacheFlushing当代码缓存被填满时让 JVM 放弃一些编译代码<h2 id="内存调优"><a href="#内存调优" class="headerlink" title="内存调优"></a>内存调优</h2>所有已制定的 HotSpot 内存管理和垃圾回收算法都基于一个相同的堆内存划分：新生代（young generation）里存储着新分配的和较年轻的对象，老年代（old generation）里存储着长寿的对象。在此之外，永久代（permanent generation）存储着那些需要伴随整个 JVM 生命周期的对象，比如，已加载的对象的类定义或者 String 对象内部 Cache。接下来，我们将假设堆内存是按照新生代、老年代和永久代这一经典策略划分的。然而，其他的一些堆内存划分策略也是可行的，一个突出的例子就是新的 G1 垃圾回收器，它模糊了新生代和老年代之间的区别。此外，目前的开发进程似乎表明在未来的 HotSpot JVM 版本中，将不会区分老年代和永久代。</li></ul></li></ul></li><li>-Xms and -Xmx (or: -XX:InitialHeapSize and -XX:MaxHeapSize)指定 JVM 的初始和最大堆内存大小新生代垃圾回收</li><li>-XX:NewSize and -XX:MaxNewSize新生代只是整个堆的一部分，新生代设置的越大，老年代区域就会减少</li><li>-XX:NewRatio动态分配新生代与老生代比例</li><li>-XX:SurvivorRatio 动态分配新生代的伊甸园区与幸存区（伊甸园区大于幸存区【俩个幸存区大小相同】）</li><li>-XX:+PrintTenuringDistribution</li><li>-XX:InitialTenuringThreshold， -XX:MaxTenuringThreshold and -XX:TargetSurvivorRatio</li><li>-XX:+NeverTenure and -XX:+AlwaysTenure</li></ul><h2 id="GC-日志（垃圾收集）"><a href="#GC-日志（垃圾收集）" class="headerlink" title="GC 日志（垃圾收集）"></a>GC 日志（垃圾收集）</h2><p>作用：记录了每一次的 GC 的执行时间和执行结果，通过分析 GC 日志可以优化堆设置和 GC 设置，或者改进应用程序的对象分配模式</p><ul><li><p>-XX:+PrintGC（- verbose:gc） 简单日志模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">每一次新生代（young generation）的 GC 和每一次的 Full GC 打印一行信息。</span><br><span class="line">[GC 246656K-&gt;243120K(376320K), 0.0929090 secs]</span><br><span class="line">gc类型 gc使用的前的堆空间 gc使用后的堆大小 当前堆容量 gc持续时间</span><br></pre></td></tr></table></figure></li><li><p>XX:PrintGCDetails 详细 GC 日志模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[GC[PSYoungGen: 142816K-&gt;10752K(142848K)] 246648K-&gt;243136K(375296K), 0.0935090 secs]</span><br><span class="line">[Times: user=0.55 sys=0.10, real=0.09 secs]</span><br><span class="line"></span><br><span class="line">这是一次在 young generation 中的 GC，它将已使用的堆空间从 246648K 减少到了 243136K，用时 0.0935090 秒。此外我们还可以得到更多的信息：所使用的垃圾收集器（即 PSYoungGen）、young generation 的大小和使用情况（在这个例子中 “PSYoungGen” 垃圾收集器将 young generation 所使用的堆空间从 142816K 减少到 10752K）。</span><br><span class="line">CPU 时间信息 =用户空间+系统空间</span><br><span class="line">real gc运行真实时间</span><br></pre></td></tr></table></figure></li><li><p>-XX:+PrintGCTimeStamps 和 - XX:+PrintGCDateStamps【绝对时间】将时间和日期也加到 GC 日志中</p></li><li>-Xloggc（- XX:+PrintGC - XX:+PrintGCTimeStamps）输出到指定的文件</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;jvm参数&quot;&gt;&lt;a href=&quot;#jvm参数&quot; class=&quot;headerlink&quot; title=&quot;jvm参数&quot;&gt;&lt;/a&gt;jvm参数&lt;/h1&gt;&lt;h2 id=&quot;JVM-类型以及编译器模式&quot;&gt;&lt;a href=&quot;#JVM-类型以及编译器模式&quot; class=&quot;header
      
    
    </summary>
    
      <category term="java" scheme="https://github.com/xuegangliu/blog/categories/java/"/>
    
    
      <category term="knowledge" scheme="https://github.com/xuegangliu/blog/tags/knowledge/"/>
    
      <category term="java_jvm" scheme="https://github.com/xuegangliu/blog/tags/java-jvm/"/>
    
  </entry>
  
  <entry>
    <title>设计模式介绍</title>
    <link href="https://github.com/xuegangliu/blog/2017/07/19/idea/design_patterns_base/"/>
    <id>https://github.com/xuegangliu/blog/2017/07/19/idea/design_patterns_base/</id>
    <published>2017-07-19T13:33:02.000Z</published>
    <updated>2017-07-13T15:33:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式-Design-pattern"><a href="#设计模式-Design-pattern" class="headerlink" title="设计模式(Design pattern)"></a>设计模式(Design pattern)</h1><h2 id="设计模式简介"><a href="#设计模式简介" class="headerlink" title="设计模式简介"></a>设计模式简介</h2><ol><li><strong>设计模式(Design pattern)</strong> 代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。</li><li><strong>设计模式</strong>是软件开发人员在软件开发过程中面临的一般问题的解决方案。</li><li>这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</li><li><strong>设计模式</strong>是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。</li><li>使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 </li><li>毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。</li><li>项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。</li></ol><h2 id="设计模式原则"><a href="#设计模式原则" class="headerlink" title="设计模式原则"></a><strong>设计模式原则</strong></h2><ul><li><em>开闭原则（Open Close Principle）</em></li></ul><p>开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p><ul><li><em>里氏代换原则（Liskov Substitution Principle）</em></li></ul><p>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p><ul><li><em>依赖倒转原则（Dependence Inversion Principle）</em></li></ul><p>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p><ul><li><em>接口隔离原则（Interface Segregation Principle）</em></li></ul><p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p><ul><li><p><em>迪米特法则，又称最少知道原则（Demeter Principle）</em></p><p>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p></li><li><p><em>合成复用原则（Composite Reuse Principle）</em></p><p>合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。</p></li></ul><h2 id="设计模式的使用"><a href="#设计模式的使用" class="headerlink" title="设计模式的使用"></a>设计模式的使用</h2><ul><li>开发人员的共同平台</li></ul><p>设计模式提供了一个标准的术语系统，且具体到特定的情景。例如，单例设计模式意味着使用单个对象，这样所有熟悉单例设计模式的开发人员都能使用单个对象，并且可以通过这种方式告诉对方，程序使用的是单例模式。</p><ul><li>最佳的实践  </li></ul><p>设计模式已经经历了很长一段时间的发展，它们提供了软件开发过程中面临的一般问题的最佳解决方案。学习这些模式有助于经验不足的开发人员通过一种简单快捷的方式来学习软件设计。</p><hr><h1 id="设计模式类型"><a href="#设计模式类型" class="headerlink" title="设计模式类型"></a>设计模式类型</h1><p><strong>创建型模式</strong></p><p>这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用新的运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</p><ul><li><em>工厂模式（Factory Pattern）</em></li><li><em>抽象工厂模式（Abstract Factory Pattern）</em>  </li><li><em>单例模式（Singleton Pattern）</em> </li><li><em>建造者模式（Builder Pattern）</em> </li><li><em>原型模式（Prototype Pattern）</em></li></ul><p><strong>结构型模式</strong></p><p>这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。    </p><ul><li><em>适配器模式（Adapter Pattern）</em>  </li><li><em>桥接模式（Bridge Pattern）</em></li><li><em>过滤器模式（Filter、Criteria Pattern）</em></li><li><em>组合模式（Composite Pattern）</em></li><li><em>装饰器模式（Decorator Pattern）</em></li><li><em>外观模式（Facade Pattern）</em></li><li><em>享元模式（Flyweight Pattern）</em></li><li><em>代理模式（Proxy Pattern）</em></li></ul><p><strong>行为型模式</strong></p><p>这些设计模式特别关注对象之间的通信。    </p><ul><li><em>责任链模式（Chain of Responsibility Pattern）</em></li><li><em>命令模式（Command Pattern）</em></li><li><em>解释器模式（Interpreter Pattern）</em></li><li><em>迭代器模式（Iterator Pattern）</em></li><li><em>中介者模式（Mediator Pattern）</em></li><li><em>备忘录模式（Memento Pattern）</em></li><li><em>观察者模式（Observer Pattern）</em></li><li><em>状态模式（State Pattern）</em></li><li><em>空对象模式（Null Object Pattern）</em></li><li><em>策略模式（Strategy Pattern）</em></li><li><em>模板模式（Template Pattern）</em></li><li><em>访问者模式（Visitor Pattern）</em></li></ul><p><strong>J2EE 模式</strong></p><p>这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。    </p><ul><li><em>MVC 模式（MVC Pattern）</em></li><li><em>业务代表模式（Business Delegate Pattern）</em></li><li><em>组合实体模式（Composite Entity Pattern）</em></li><li><em>数据访问对象模式（Data Access Object Pattern）</em></li><li><em>前端控制器模式（Front Controller Pattern）</em></li><li><em>拦截过滤器模式（Intercepting Filter Pattern）</em></li><li><em>服务定位器模式（Service Locator Pattern）</em></li><li><em>传输对象模式（Transfer Object Pattern）</em></li></ul><h2 id="设计模式直接的关系"><a href="#设计模式直接的关系" class="headerlink" title="设计模式直接的关系"></a>设计模式直接的关系</h2><p><img src="/blog/images/java/design-patterns.jpg" alt="设计模式图"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;设计模式-Design-pattern&quot;&gt;&lt;a href=&quot;#设计模式-Design-pattern&quot; class=&quot;headerlink&quot; title=&quot;设计模式(Design pattern)&quot;&gt;&lt;/a&gt;设计模式(Design pattern)&lt;/h1&gt;&lt;h2
      
    
    </summary>
    
      <category term="idea" scheme="https://github.com/xuegangliu/blog/categories/idea/"/>
    
    
      <category term="knowledge" scheme="https://github.com/xuegangliu/blog/tags/knowledge/"/>
    
      <category term="design_patterns" scheme="https://github.com/xuegangliu/blog/tags/design-patterns/"/>
    
  </entry>
  
  <entry>
    <title>前端问题</title>
    <link href="https://github.com/xuegangliu/blog/2017/07/19/problem/js-problem/"/>
    <id>https://github.com/xuegangliu/blog/2017/07/19/problem/js-problem/</id>
    <published>2017-07-19T13:33:02.000Z</published>
    <updated>2017-07-13T15:33:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h1><hr><ol><li>ajax怎么解决跨域？<ul><li>1，代理（通过后台操作）</li><li>2，JSONP（添加响应头，允许跨域 ）<pre><code>addHeader(‘Access-Control-Allow-Origin:*’);//允许所有来源访问  addHeader(‘Access-Control-Allow-Method:POST,GET’);//允许访问的方式</code></pre></li><li>3，在ajax的dataType方式改为“jsonp”</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;问题记录&quot;&gt;&lt;a href=&quot;#问题记录&quot; class=&quot;headerlink&quot; title=&quot;问题记录&quot;&gt;&lt;/a&gt;问题记录&lt;/h1&gt;&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;ajax怎么解决跨域？&lt;ul&gt;
&lt;li&gt;1，代理（通过后台操作）&lt;/li&gt;
&lt;li&gt;2，JSONP（添
      
    
    </summary>
    
      <category term="problem" scheme="https://github.com/xuegangliu/blog/categories/problem/"/>
    
    
      <category term="simple" scheme="https://github.com/xuegangliu/blog/tags/simple/"/>
    
      <category term="javascript" scheme="https://github.com/xuegangliu/blog/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>亚信中国</title>
    <link href="https://github.com/xuegangliu/blog/2017/06/08/work/asiainfo/"/>
    <id>https://github.com/xuegangliu/blog/2017/06/08/work/asiainfo/</id>
    <published>2017-06-08T09:00:00.000Z</published>
    <updated>2017-06-08T09:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>通信行业</p><h2 id="参与项目"><a href="#参与项目" class="headerlink" title="参与项目"></a>参与项目</h2><ul><li>中国铁塔</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通信行业&lt;/p&gt;
&lt;h2 id=&quot;参与项目&quot;&gt;&lt;a href=&quot;#参与项目&quot; class=&quot;headerlink&quot; title=&quot;参与项目&quot;&gt;&lt;/a&gt;参与项目&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;中国铁塔&lt;/li&gt;
&lt;/ul&gt;

      
    
    </summary>
    
      <category term="work" scheme="https://github.com/xuegangliu/blog/categories/work/"/>
    
    
      <category term="communication" scheme="https://github.com/xuegangliu/blog/tags/communication/"/>
    
  </entry>
  
  <entry>
    <title>docker基础</title>
    <link href="https://github.com/xuegangliu/blog/2017/01/09/server/docker_base/"/>
    <id>https://github.com/xuegangliu/blog/2017/01/09/server/docker_base/</id>
    <published>2017-01-09T14:08:37.000Z</published>
    <updated>2017-01-09T14:08:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h1><ul><li>service docker start </li><li>systemctl start docker</li><li>systemctl enable docker</li></ul><h2 id="Docker-中国官方镜像加速可通过-registry-docker-cn-com"><a href="#Docker-中国官方镜像加速可通过-registry-docker-cn-com" class="headerlink" title="Docker 中国官方镜像加速可通过 registry.docker-cn.com"></a>Docker 中国官方镜像加速可通过 registry.docker-cn.com</h2><p><code>docker --registry-mirror=https://registry.docker-cn.com daemon</code></p><ul><li>为了永久性保留更改，您可以修改 /etc/docker/daemon.json 文件并添加上 registry-mirrors 键值。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">docker --registry-mirror=https://registry.docker-cn.com daemon</span><br><span class="line"></span><br><span class="line">docker run --name some-mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag</span><br></pre></td></tr></table></figure><h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><ul><li>ALTER USER ‘root‘@’%’ IDENTIFIED WITH mysql_native_password BY ‘你的密码’;<br>FLUSH PRIVILEGES;</li></ul><h2 id="mongo"><a href="#mongo" class="headerlink" title="mongo"></a>mongo</h2><ul><li>docker pull  mongo </li><li>docker run  –name some-mongo   -p 27017:27017   -d mongo   –auth     //这里的–name 放在前面并映射端口</li><li>docker    exec  -it  容器ID   /bin/bash     //进入容器</li><li>mongo  </li><li>use admin</li><li>db.createUser({user:”root”,pwd:”root”,roles:[{role:’root’,db:’admin’}]})   //创建用户,此用户创建成功,则后续操作都需要用户认证</li><li>exit  </li></ul><h2 id="ftp"><a href="#ftp" class="headerlink" title="ftp"></a>ftp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull docker.io/fauria/vsftpd</span><br><span class="line">docker run -d -v /home/vsftpd:/home/vsftpd -p 20:20 -p 21:21 -p 21100-21110:21100-21110 -e FTP_USER=test -e FTP_PASS=test --name vsftpd fauria/vsftpd</span><br></pre></td></tr></table></figure><ul><li>会以登录用户名 (test) 创建一个目录 (/home/vsftpd/test) 作为 ftp 根目录</li><li>测试时发现不加 -p 20:20 依然可以正常操作</li></ul><h2 id="sftp"><a href="#sftp" class="headerlink" title="sftp"></a>sftp</h2><ul><li>使用命令sudo docker pull luzifer/sftp-share</li><li>构建docker run -d -p 2022:22 -e USER=myuser -e PASS=myverysecretpassword luzifer/sftp-share</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;docker&quot;&gt;&lt;a href=&quot;#docker&quot; class=&quot;headerlink&quot; title=&quot;docker&quot;&gt;&lt;/a&gt;docker&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;service docker start &lt;/li&gt;
&lt;li&gt;systemctl start d
      
    
    </summary>
    
      <category term="server" scheme="https://github.com/xuegangliu/blog/categories/server/"/>
    
    
      <category term="docker" scheme="https://github.com/xuegangliu/blog/tags/docker/"/>
    
  </entry>
  
</feed>
