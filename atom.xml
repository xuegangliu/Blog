<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>俩天的博客</title>
  
  <subtitle>日常记录</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://github.com/xuegangliu/blog/"/>
  <updated>2019-01-10T10:36:25.000Z</updated>
  <id>https://github.com/xuegangliu/blog/</id>
  
  <author>
    <name>xuegangliu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计原则</title>
    <link href="https://github.com/xuegangliu/blog/2019/01/10/other/design-principles/"/>
    <id>https://github.com/xuegangliu/blog/2019/01/10/other/design-principles/</id>
    <published>2019-01-10T10:36:25.000Z</published>
    <updated>2019-01-10T10:36:25.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面向对象原则"><a href="#面向对象原则" class="headerlink" title="面向对象原则"></a>面向对象原则</h2><p>Java编程最基本的原则就是要追求高内聚和低耦合的解决方案和代码模块设计<br>SOLID原则：S.O.L.I.D是面向对象设计和编程(OOD&amp;OOP)中几个重要编码原则(Programming Priciple)的首字母缩写。</p><table><thead><tr><th>English</th><th>中文</th></tr></thead><tbody><tr><td>SRP The Single Responsibility Principle</td><td>单一责任原则</td></tr><tr><td>OCP The Open Closed Principle</td><td>开放封闭原则</td></tr><tr><td>LSP The Liskov Substitution Principle</td><td>里氏替换原则</td></tr><tr><td>ISP The Interface Segregation Principle</td><td>接口分离原则</td></tr><tr><td>DIP The Dependency Inversion Principle</td><td>依赖倒置原则</td></tr></tbody></table><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul><li><ol><li>单一责任原则（SRP）[单类单功能]<br> 当需要修改某个类的时候原因有且只有一个。换句话说就是让一个类只做一种类型责任，当这个类需要承当其他类型的责任的时候，就需要分解这个类。 类被修改的几率很大，因此应该专注于单一的功能。如果你把多个功能放在同一个类中，功能之间就形成了关联，改变其中一个功能，有可能中止另一个功能，这时就需要新一轮的测试来避免可能出现的问题，非常耗时耗力。</li></ol></li><li><ol start="2"><li>开放封闭原则（OCP）[新扩展，旧不变]<br>软件实体应该是可扩展，而不可修改的。也就是说，对扩展是开放的，而对修改是封闭的。这个原则是诸多面向对象编程原则中最抽象、最难理解的一个。<ul><li>(1)通过增加代码来扩展功能，而不是修改已经存在的代码。</li><li>(2)若客户模块和服务模块遵循同一个接口来设计，则客户模块可以不关心服务模块的类型，服务模块可以方便扩展服务(代码)。</li><li>(3)OCP支持替换的服务，而不用修改客户模块。</li></ul></li></ol></li><li><ol start="3"><li>里氏替换原则（LSP）<br>当一个子类的实例应该能够替换任何其超类的实例时，它们之间才具有is-A关系<br>客户模块不应关心服务模块的是如何工作的；同样的接口模块之间，可以在不知道服务模块代码的情况下，进行替换。即接口或父类出现的地方，实现接口的类或子类可以代入。</li></ol></li><li><ol start="4"><li>接口分离原则（ISP）[解决多余]<br>不能强迫用户去依赖那些他们不使用的接口。换句话说，使用多个专门的接口比使用单一的总接口总要好。<br>客户模块不应该依赖大的接口，应该裁减为小的接口给客户模块使用，以减少依赖性。如Java中一个类实现多个接口，不同的接口给不用的客户模块使用，而不是提供给客户模块一个大的接口。</li></ol></li><li><ol start="5"><li>依赖注入或倒置原则（DIP）<ul><li><ol><li>高层模块不应该依赖于低层模块，二者都应该依赖于抽象 </li></ol></li><li><ol start="2"><li>抽象不应该依赖于细节，细节应该依赖于抽象<br>这个设计原则的亮点在于任何被DI框架注入的类很容易用mock对象进行测试和维护，因为对象创建代码集中在框架中，客户端代码也不混乱。有很多方式可以实现依赖倒置，比如像AspectJ等的AOP（Aspect Oriented programming）框架使用的字节码技术，或Spring框架使用的代理等。</li></ol></li><li>(1).高层模块不要依赖低层模块；</li><li>(2).高层和低层模块都要依赖于抽象；</li><li>(3).抽象不要依赖于具体实现；<br>-(4).具体实现要依赖于抽象；</li><li>(5).抽象和接口使模块之间的依赖分离。</li></ul></li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;面向对象原则&quot;&gt;&lt;a href=&quot;#面向对象原则&quot; class=&quot;headerlink&quot; title=&quot;面向对象原则&quot;&gt;&lt;/a&gt;面向对象原则&lt;/h2&gt;&lt;p&gt;Java编程最基本的原则就是要追求高内聚和低耦合的解决方案和代码模块设计&lt;br&gt;SOLID原则：S.O.L.
      
    
    </summary>
    
      <category term="design" scheme="https://github.com/xuegangliu/blog/categories/design/"/>
    
    
      <category term="design" scheme="https://github.com/xuegangliu/blog/tags/design/"/>
    
  </entry>
  
  <entry>
    <title>github_emoji</title>
    <link href="https://github.com/xuegangliu/blog/2019/01/10/other/github_emoji/"/>
    <id>https://github.com/xuegangliu/blog/2019/01/10/other/github_emoji/</id>
    <published>2019-01-10T10:36:25.000Z</published>
    <updated>2019-01-10T10:36:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="github-emoji"><a href="#github-emoji" class="headerlink" title="github_emoji"></a>github_emoji</h1><p>emoji图标使用</p><h2 id="emoji-指南"><a href="#emoji-指南" class="headerlink" title="emoji 指南"></a>emoji 指南</h2><table><thead><tr><th style="text-align:left">emoji</th><th style="text-align:left">emoji 代码</th><th style="text-align:left">commit 说明</th></tr></thead><tbody><tr><td style="text-align:left">:tada: (庆祝)</td><td style="text-align:left"><code>:tada:</code></td><td style="text-align:left">初次提交</td></tr><tr><td style="text-align:left">:sparkles: (火花)</td><td style="text-align:left"><code>:sparkles:</code></td><td style="text-align:left">引入新功能</td></tr><tr><td style="text-align:left">:bookmark: (书签)</td><td style="text-align:left"><code>:bookmark:</code></td><td style="text-align:left">发行/版本标签</td></tr><tr><td style="text-align:left">:bug: (bug)</td><td style="text-align:left"><code>:bug:</code></td><td style="text-align:left">修复 bug</td></tr><tr><td style="text-align:left">:ambulance: (急救车)</td><td style="text-align:left"><code>:ambulance:</code></td><td style="text-align:left">重要补丁</td></tr><tr><td style="text-align:left">:globe_with_meridians: (地球)</td><td style="text-align:left"><code>:globe_with_meridians:</code></td><td style="text-align:left">国际化与本地化</td></tr><tr><td style="text-align:left">:lipstick: (口红)</td><td style="text-align:left"><code>:lipstick:</code></td><td style="text-align:left">更新 UI 和样式文件</td></tr><tr><td style="text-align:left">:rotating_light: (警车灯)</td><td style="text-align:left"><code>:rotating_light:</code></td><td style="text-align:left">移除 linter 警告</td></tr><tr><td style="text-align:left">:wrench: (扳手)</td><td style="text-align:left"><code>:wrench:</code></td><td style="text-align:left">修改配置文件</td></tr><tr><td style="text-align:left">:heavy_plus_sign: (加号)</td><td style="text-align:left"><code>:heavy_plus_sign:</code></td><td style="text-align:left">增加一个依赖</td></tr><tr><td style="text-align:left">:heavy_minus_sign: (减号)</td><td style="text-align:left"><code>:heavy_minus_sign:</code></td><td style="text-align:left">减少一个依赖</td></tr><tr><td style="text-align:left">:arrow_up: (上升箭头)</td><td style="text-align:left"><code>:arrow_up:</code></td><td style="text-align:left">升级依赖</td></tr><tr><td style="text-align:left">:arrow_down: (下降箭头)</td><td style="text-align:left"><code>:arrow_down:</code></td><td style="text-align:left">降级依赖</td></tr><tr><td style="text-align:left">:zap: (闪电)<br>:racehorse: (赛马)</td><td style="text-align:left"><code>:zap:</code><br><code>:racehorse:</code></td><td style="text-align:left">提升性能</td></tr><tr><td style="text-align:left">:chart_with_upwards_trend: (上升趋势图)</td><td style="text-align:left"><code>:chart_with_upwards_trend:</code></td><td style="text-align:left">添加分析或跟踪代码</td></tr><tr><td style="text-align:left">:rocket: (火箭)</td><td style="text-align:left"><code>:rocket:</code></td><td style="text-align:left">部署功能</td></tr><tr><td style="text-align:left">:white_check_mark: (白色复选框)</td><td style="text-align:left"><code>:white_check_mark:</code></td><td style="text-align:left">增加测试</td></tr><tr><td style="text-align:left">:memo: (备忘录)</td><td style="text-align:left"><code>:memo:</code></td><td style="text-align:left">撰写文档</td></tr><tr><td style="text-align:left">:hammer: (锤子)</td><td style="text-align:left"><code>:hammer:</code></td><td style="text-align:left">重大重构</td></tr><tr><td style="text-align:left">:art: (调色板)</td><td style="text-align:left"><code>:art:</code></td><td style="text-align:left">改进代码结构/代码格式</td></tr><tr><td style="text-align:left">:fire: (火焰)</td><td style="text-align:left"><code>:fire:</code></td><td style="text-align:left">移除代码或文件</td></tr><tr><td style="text-align:left">:pencil2: (铅笔)</td><td style="text-align:left"><code>:pencil2:</code></td><td style="text-align:left">修复 typo</td></tr><tr><td style="text-align:left">:construction: (施工)</td><td style="text-align:left"><code>:construction:</code></td><td style="text-align:left">工作进行中</td></tr><tr><td style="text-align:left">:construction_worker: (工人)</td><td style="text-align:left"><code>:construction_worker:</code></td><td style="text-align:left">添加 CI 构建系统</td></tr><tr><td style="text-align:left">:green_heart: (绿心)</td><td style="text-align:left"><code>:green_heart:</code></td><td style="text-align:left">修复 CI 构建问题</td></tr><tr><td style="text-align:left">:lock: (锁)</td><td style="text-align:left"><code>:lock:</code></td><td style="text-align:left">修复安全问题</td></tr><tr><td style="text-align:left">:whale: (鲸鱼)</td><td style="text-align:left"><code>:whale:</code></td><td style="text-align:left">Docker 相关工作</td></tr><tr><td style="text-align:left">:apple: (苹果)</td><td style="text-align:left"><code>:apple:</code></td><td style="text-align:left">修复 macOS 下的问题</td></tr><tr><td style="text-align:left">:penguin: (企鹅)</td><td style="text-align:left"><code>:penguin:</code></td><td style="text-align:left">修复 Linux 下的问题</td></tr><tr><td style="text-align:left">:checkered_flag: (旗帜)</td><td style="text-align:left"><code>:checked_flag:</code></td><td style="text-align:left">修复 Windows 下的问题</td></tr></tbody></table><h2 id="简单常用emoji"><a href="#简单常用emoji" class="headerlink" title="简单常用emoji"></a>简单常用emoji</h2><p><a href="https://segmentfault.com/a/1190000009649780#articleHeader6" target="_blank" rel="noopener">emoji分类</a><br>简单</p><ul><li>:ok:</li><li>:up:</li><li>:cool:</li><li>:new:</li><li>:top:</li><li>:red_circle:</li><li>:white_circle:</li><li>:black_circle:</li><li>:link:</li><li>:100:</li><li>:o:</li><li>:x:</li><li>:copyright:</li><li>:tm:</li><li>:on:</li><li>:o2:</li><li>:a:</li><li>:ab:</li><li>:recycle:</li><li>:b:</li><li>:vs:</li><li>:sos:</li><li>:id:</li><li>:m:</li><li>:mens:</li><li>:free:</li><li>:repeat:</li><li>:hash:</li><li>:cn:</li><li>:smile:</li><li>:rage:</li><li>:shit:</li><li>:v:</li><li>:heart:</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;github-emoji&quot;&gt;&lt;a href=&quot;#github-emoji&quot; class=&quot;headerlink&quot; title=&quot;github_emoji&quot;&gt;&lt;/a&gt;github_emoji&lt;/h1&gt;&lt;p&gt;emoji图标使用&lt;/p&gt;
&lt;h2 id=&quot;emoji-指南
      
    
    </summary>
    
      <category term="emoji" scheme="https://github.com/xuegangliu/blog/categories/emoji/"/>
    
    
      <category term="github" scheme="https://github.com/xuegangliu/blog/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>travis配置</title>
    <link href="https://github.com/xuegangliu/blog/2019/01/08/tools/travis%E6%9E%84%E5%BB%BA/"/>
    <id>https://github.com/xuegangliu/blog/2019/01/08/tools/travis构建/</id>
    <published>2019-01-08T16:52:37.000Z</published>
    <updated>2019-01-08T16:52:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="travis"><a href="#travis" class="headerlink" title="travis"></a>travis</h1><p>构建github代码库中的项目</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p><code>travis.yml</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># 选择项目的语言及版本</span><br><span class="line">language: python</span><br><span class="line">python:</span><br><span class="line">  - &quot;2.7&quot;</span><br><span class="line"></span><br><span class="line"># 打包之前的操作</span><br><span class="line">before_install: &quot;sudo apt-get update&quot;</span><br><span class="line"># 依赖安装等</span><br><span class="line">install: &quot;pip install -q -r requirements.txt --use-mirrors&quot;</span><br><span class="line"></span><br><span class="line"># 构建</span><br><span class="line">script: make html</span><br><span class="line"></span><br><span class="line"># 限制项目分支</span><br><span class="line">branches:</span><br><span class="line">  only:</span><br><span class="line">    - mybranch</span><br><span class="line"></span><br><span class="line">## 构建完成之后的命令</span><br><span class="line">after_success:</span><br><span class="line">    &quot;find ./make/output -type f -exec curl --ftp-create-dirs -u $FTP_USER:$FTP_PASSWORD -T &#123;&#125; ftp://123.45.67.89/myproject/&#123;&#125; \\;&quot;</span><br><span class="line"></span><br><span class="line">#环境变量</span><br><span class="line">env:</span><br><span class="line">  global:</span><br><span class="line">    - &quot;FTP_USER=myusername&quot;</span><br><span class="line">    - &quot;FTP_PASSWORD=mypassword&quot;</span><br><span class="line"></span><br><span class="line"># 邮件通知</span><br><span class="line">notifications:</span><br><span class="line">  email:</span><br><span class="line">    recipients:</span><br><span class="line">        - 1453860636@qq.com</span><br><span class="line">    on_success: change</span><br><span class="line">    on_failure: always</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;travis&quot;&gt;&lt;a href=&quot;#travis&quot; class=&quot;headerlink&quot; title=&quot;travis&quot;&gt;&lt;/a&gt;travis&lt;/h1&gt;&lt;p&gt;构建github代码库中的项目&lt;/p&gt;
&lt;h2 id=&quot;配置&quot;&gt;&lt;a href=&quot;#配置&quot; class=&quot;h
      
    
    </summary>
    
      <category term="Travis" scheme="https://github.com/xuegangliu/blog/categories/Travis/"/>
    
    
      <category term="build" scheme="https://github.com/xuegangliu/blog/tags/build/"/>
    
      <category term="Travis" scheme="https://github.com/xuegangliu/blog/tags/Travis/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu结构</title>
    <link href="https://github.com/xuegangliu/blog/2018/11/09/system/Ubuntu%E7%BB%93%E6%9E%84/"/>
    <id>https://github.com/xuegangliu/blog/2018/11/09/system/Ubuntu结构/</id>
    <published>2018-11-09T15:28:01.000Z</published>
    <updated>2018-11-09T15:28:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p><img src="/book/images/linux/dir1.png" alt="目录结构1"><br><img src="/book/images/linux/dir2.png" alt="目录结构2"><br><img src="/book/images/linux/dir3.png" alt="目录结构2"><br><img src="/book/images/linux/dir4.png" alt="目录结构2"></p><h2 id="软件包管理"><a href="#软件包管理" class="headerlink" title="软件包管理"></a>软件包管理</h2><p>Ubuntu更新软件时的软件源配置文件是/etc/apt/sources.list。<br>ubuntu的官方软件源分为4类：</p><ul><li>main：这个是官方维护的基本库。</li><li>restricted：官方维护的其他自由软件。</li><li>universe：自由软件，但是官方不维护。</li><li>multiverse：非自由软件，官方不维护。</li></ul><p>apt<br>apt是一套完整的软件包管理方案。除了最常用apt-get之外，还包括了一系列的客户端和服务器软件。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-cache search gstreamer 搜索名字中包含gstreamer的软件包。</span><br><span class="line">sudo add-apt-repository ppa:tualatrix/ppa添加新的软件源。</span><br></pre></td></tr></table></figure></p><h3 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令"></a>安装命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo  apt-get install foo</span><br><span class="line">dpkg -i *.deb</span><br><span class="line">wget http://*</span><br></pre></td></tr></table></figure><h3 id="卸载命令"><a href="#卸载命令" class="headerlink" title="卸载命令"></a>卸载命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get --purge remove foo</span><br><span class="line">sudo  apt-get remove  foo</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录结构&quot;&gt;&lt;a href=&quot;#目录结构&quot; class=&quot;headerlink&quot; title=&quot;目录结构&quot;&gt;&lt;/a&gt;目录结构&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/book/images/linux/dir1.png&quot; alt=&quot;目录结构1&quot;&gt;&lt;br&gt;&lt;img sr
      
    
    </summary>
    
      <category term="Linux" scheme="https://github.com/xuegangliu/blog/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://github.com/xuegangliu/blog/tags/Linux/"/>
    
      <category term="Ubuntu" scheme="https://github.com/xuegangliu/blog/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu基础命令</title>
    <link href="https://github.com/xuegangliu/blog/2018/11/09/system/%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://github.com/xuegangliu/blog/2018/11/09/system/基本使用命令/</id>
    <published>2018-11-09T15:28:01.000Z</published>
    <updated>2018-11-09T15:28:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p><img src="dir1.png" alt="目录结构1"><br><img src="dir2.png" alt="目录结构2"><br><img src="dir3.png" alt="目录结构2"><br><img src="dir4.png" alt="目录结构2"></p><h2 id="软件包管理"><a href="#软件包管理" class="headerlink" title="软件包管理"></a>软件包管理</h2><p>Ubuntu更新软件时的软件源配置文件是/etc/apt/sources.list。<br>ubuntu的官方软件源分为4类：</p><ul><li>main：这个是官方维护的基本库。</li><li>restricted：官方维护的其他自由软件。</li><li>universe：自由软件，但是官方不维护。</li><li>multiverse：非自由软件，官方不维护。</li></ul><p>apt<br>apt是一套完整的软件包管理方案。除了最常用apt-get之外，还包括了一系列的客户端和服务器软件。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-cache search gstreamer 搜索名字中包含gstreamer的软件包。</span><br><span class="line">sudo add-apt-repository ppa:tualatrix/ppa添加新的软件源。</span><br></pre></td></tr></table></figure></p><h3 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令"></a>安装命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo  apt-get install foo</span><br><span class="line">dpkg -i *.deb</span><br><span class="line">wget http://*</span><br></pre></td></tr></table></figure><h3 id="卸载命令"><a href="#卸载命令" class="headerlink" title="卸载命令"></a>卸载命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get --purge remove foo</span><br><span class="line">sudo  apt-get remove  foo</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录结构&quot;&gt;&lt;a href=&quot;#目录结构&quot; class=&quot;headerlink&quot; title=&quot;目录结构&quot;&gt;&lt;/a&gt;目录结构&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;dir1.png&quot; alt=&quot;目录结构1&quot;&gt;&lt;br&gt;&lt;img src=&quot;dir2.png&quot; alt=&quot;目
      
    
    </summary>
    
      <category term="Linux" scheme="https://github.com/xuegangliu/blog/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://github.com/xuegangliu/blog/tags/Linux/"/>
    
      <category term="Ubuntu" scheme="https://github.com/xuegangliu/blog/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>JVM性能调优</title>
    <link href="https://github.com/xuegangliu/blog/2018/11/09/java/JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    <id>https://github.com/xuegangliu/blog/2018/11/09/java/JVM性能调优/</id>
    <published>2018-11-09T15:19:01.000Z</published>
    <updated>2018-11-09T15:19:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM性能调优"><a href="#JVM性能调优" class="headerlink" title="JVM性能调优"></a>JVM性能调优</h1><h2 id="一、JVM内存模型及垃圾收集算法"><a href="#一、JVM内存模型及垃圾收集算法" class="headerlink" title="一、JVM内存模型及垃圾收集算法"></a>一、JVM内存模型及垃圾收集算法</h2><h3 id="1-根据Java虚拟机规范，JVM将内存划分为："><a href="#1-根据Java虚拟机规范，JVM将内存划分为：" class="headerlink" title="1.根据Java虚拟机规范，JVM将内存划分为："></a>1.根据Java虚拟机规范，JVM将内存划分为：</h3><ul><li>New（年轻代)[启动分配堆内存]（-Xmx:3G）<br>  年轻代用来存放JVM刚分配的Java对象<ul><li>Eden：Eden用来存放JVM刚分配的对象</li><li>Survivor1</li><li>Survivro2：两个Survivor空间一样大，当Eden中的对象经过垃圾回收没有被回收掉时，会在两个Survivor之间来回Copy，当满足某个条件，比如Copy次数，就会被Copy到Tenured。显然，Survivor只是增加了对象在年轻代中的逗留时间，增加了被垃圾回收的可能性。</li></ul></li><li>Tenured（年老代）[启动分配堆内存]（-Xmx:3G）</li><li>永久代（Perm）[JVM分配内存] （-XX:PermSize -XX:MaxPermSize）</li></ul><h3 id="2-垃圾回收算法"><a href="#2-垃圾回收算法" class="headerlink" title="2.垃圾回收算法"></a>2.垃圾回收算法</h3><p>垃圾回收算法可以分为三类，都基于标记-清除（复制）算法：</p><ul><li>Serial算法（单线程）</li><li>并行算法</li><li>并发算法</li></ul><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://blog.csdn.net/chen77716/article/details/5695893" target="_blank" rel="noopener">JVM性能调优</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JVM性能调优&quot;&gt;&lt;a href=&quot;#JVM性能调优&quot; class=&quot;headerlink&quot; title=&quot;JVM性能调优&quot;&gt;&lt;/a&gt;JVM性能调优&lt;/h1&gt;&lt;h2 id=&quot;一、JVM内存模型及垃圾收集算法&quot;&gt;&lt;a href=&quot;#一、JVM内存模型及垃圾收集算法&quot;
      
    
    </summary>
    
      <category term="Java" scheme="https://github.com/xuegangliu/blog/categories/Java/"/>
    
    
      <category term="Java" scheme="https://github.com/xuegangliu/blog/tags/Java/"/>
    
      <category term="JVM" scheme="https://github.com/xuegangliu/blog/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM命令工具</title>
    <link href="https://github.com/xuegangliu/blog/2018/02/09/tools/JVM%E5%91%BD%E4%BB%A4%E5%B7%A5%E5%85%B7/"/>
    <id>https://github.com/xuegangliu/blog/2018/02/09/tools/JVM命令工具/</id>
    <published>2018-02-09T15:14:30.000Z</published>
    <updated>2018-03-02T11:25:33.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="命令工具"><a href="#命令工具" class="headerlink" title="命令工具"></a>命令工具</h1><ul><li>jps：进程列表</li><li>jinfo：进程配置信息</li><li>jstat：内存配置信息</li><li>jstack：堆栈信息</li><li>jmap：dump堆内存快照</li><li>jhat：和jmap配合使用，分析堆内存快照文件</li></ul><h2 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h2><pre><code>-q 只输出LVMID，同进程pid-m 输出JVM启动时传给主类main()的参数。-l 输出主类全名。如果进程执行的是jar包，则输出包名。-v 输出JVM启动时JVM参数。</code></pre><p><img src="/book/images/java/jps.png" alt="jps"></p><h2 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h2><pre><code>-flag name 打印给定name对应的命令行参数值。-flag [+|-]name 更改boolean类型的命令行参数值-flag name=value 更改name对应的命令行参数值为value。-flags 打印传给JVM的命令参数值。-sysprops 打印系统属性值。</code></pre><p><img src="/book/images/java/jinfo.png" alt="jps"></p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://blog.csdn.net/dream361/article/details/77975381" target="_blank" rel="noopener">介绍</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;命令工具&quot;&gt;&lt;a href=&quot;#命令工具&quot; class=&quot;headerlink&quot; title=&quot;命令工具&quot;&gt;&lt;/a&gt;命令工具&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;jps：进程列表&lt;/li&gt;
&lt;li&gt;jinfo：进程配置信息&lt;/li&gt;
&lt;li&gt;jstat：内存配置信息&lt;/li
      
    
    </summary>
    
      <category term="Java" scheme="https://github.com/xuegangliu/blog/categories/Java/"/>
    
    
      <category term="Java" scheme="https://github.com/xuegangliu/blog/tags/Java/"/>
    
      <category term="JVM" scheme="https://github.com/xuegangliu/blog/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat调优</title>
    <link href="https://github.com/xuegangliu/blog/2018/01/09/server/Tomcat%E8%B0%83%E4%BC%98/"/>
    <id>https://github.com/xuegangliu/blog/2018/01/09/server/Tomcat调优/</id>
    <published>2018-01-09T15:16:45.000Z</published>
    <updated>2018-01-09T15:16:45.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-tomcat内存配置"><a href="#1-tomcat内存配置" class="headerlink" title="1.tomcat内存配置"></a>1.tomcat内存配置</h2><ul><li><p>案例：由于服务启动后，会有大量的excel文件进行生成，以及大量的定时任务在跑。导致服务抛出堆溢出。</p></li><li><p>解决办法：设置服务JVM参数</p><blockquote><p>JAVA_OPTS=’-Xms【初始化内存大小】 -Xmx【可以使用的最大内存】’<br>最大值设置为可用内存的最大值的80%</p></blockquote></li></ul><h2 id="2-tomcat线程优化"><a href="#2-tomcat线程优化" class="headerlink" title="2.tomcat线程优化"></a>2.tomcat线程优化</h2><h3 id="1、JDK内存优化"><a href="#1、JDK内存优化" class="headerlink" title="1、JDK内存优化"></a>1、JDK内存优化</h3><h3 id="2、连接器优化"><a href="#2、连接器优化" class="headerlink" title="2、连接器优化"></a>2、连接器优化</h3><pre><code>`maxThreads`：Tomcat使用线程来处理接收的每个请求。这个值表示Tomcat可创建的最大的线程数。默认值150。`acceptCount`：指定当所有可以使用的处理请求的线程数都被使用时，可以放到处理队列中的请求数，超过这个数的请求将不予处理。默认值10。`minSpareThreads`：Tomcat初始化时创建的线程数。默认值25。`maxSpareThreads`：一旦创建的线程超过这个值，Tomcat就会关闭不再需要的socket线程。默认值75。`enableLookups`：是否反查域名，默认值为true。为了提高处理能力，应设置为falseconnnectionTimeout：网络连接超时，默认值60000，单位：毫秒。设置为0表示永不超时，这样设置有隐患的。通常可设置为30000毫秒。`maxKeepAliveRequests`：保持请求数量，默认值100。`bufferSize`：输入流缓冲大小，默认值2048 bytes。`compression`：压缩传输，取值on/off/force，默认值off。其中和最大连接数相关的参数为maxThreads和acceptCount。如果要加大并发连接数，应同时加大这两个参数。web server允许的最大连接数还受制于*作系统的内核参数设置，通常Windows是2000个左右，Linux是1000个左右。</code></pre><h3 id="3-tomcat中如何禁止和允许列目录下的文件"><a href="#3-tomcat中如何禁止和允许列目录下的文件" class="headerlink" title="3.tomcat中如何禁止和允许列目录下的文件"></a>3.tomcat中如何禁止和允许列目录下的文件</h3><h3 id="4-tomcat中如何禁止和允许主机或IP地址访问"><a href="#4-tomcat中如何禁止和允许主机或IP地址访问" class="headerlink" title="4.tomcat中如何禁止和允许主机或IP地址访问"></a>4.tomcat中如何禁止和允许主机或IP地址访问</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-tomcat内存配置&quot;&gt;&lt;a href=&quot;#1-tomcat内存配置&quot; class=&quot;headerlink&quot; title=&quot;1.tomcat内存配置&quot;&gt;&lt;/a&gt;1.tomcat内存配置&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;案例：由于服务启动后，会有大量的excel
      
    
    </summary>
    
      <category term="Tomcat" scheme="https://github.com/xuegangliu/blog/categories/Tomcat/"/>
    
    
      <category term="Java" scheme="https://github.com/xuegangliu/blog/tags/Java/"/>
    
      <category term="Tomcat" scheme="https://github.com/xuegangliu/blog/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>JVM参数</title>
    <link href="https://github.com/xuegangliu/blog/2018/01/09/java/JVM%E5%8F%82%E6%95%B0/"/>
    <id>https://github.com/xuegangliu/blog/2018/01/09/java/JVM参数/</id>
    <published>2018-01-09T10:13:23.000Z</published>
    <updated>2018-01-09T10:13:23.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jvm参数"><a href="#jvm参数" class="headerlink" title="jvm参数"></a>jvm参数</h1><h2 id="JVM-类型以及编译器模式"><a href="#JVM-类型以及编译器模式" class="headerlink" title="JVM 类型以及编译器模式"></a>JVM 类型以及编译器模式</h2><ul><li>类型：-server and -client</li><li>版本信息：-version and -showversion</li><li>编译器模式：-Xint（解释模式 执行所有【慢】）, -Xcomp（JIT 编译器少部分功能）, 和 -    Xmixed（混合模式）</li><li>参数分类和即时（JIT）编译器诊断</li><li>标准参数<ul><li>X参数</li><li>XX参数<ul><li>-XX:+PrintCompilation 输出一些关于从字节码转化成本地代码的编译过程</li><li>-XX:+CITime JVM 关闭时得到各种编译的统计信息</li><li>-XX:+PrintFlagsFinal and -XX:+PrintFlagsInitial 打印所有 XX 参数及值</li><li>-XX:+PrintCommandLineFlags打印出那些已经被用户或者 JVM 设置过的详细的 XX 参数的名称和值 </li><li>-XX:+HeapDumpOnOutOfMemoryError and -XX:HeapDumpPath 堆内存快照</li><li>-XX:OnOutOfMemoryError 当内存溢发生时，我们甚至可以可以执行一些指令</li><li>-XX:PermSize and -XX:MaxPermSize 永久代堆内存</li><li>-XX:InitialCodeCacheSize and -XX:ReservedCodeCacheSize代码缓存</li><li>-XX:+UseCodeCacheFlushing当代码缓存被填满时让 JVM 放弃一些编译代码<h2 id="内存调优"><a href="#内存调优" class="headerlink" title="内存调优"></a>内存调优</h2>所有已制定的 HotSpot 内存管理和垃圾回收算法都基于一个相同的堆内存划分：新生代（young generation）里存储着新分配的和较年轻的对象，老年代（old generation）里存储着长寿的对象。在此之外，永久代（permanent generation）存储着那些需要伴随整个 JVM 生命周期的对象，比如，已加载的对象的类定义或者 String 对象内部 Cache。接下来，我们将假设堆内存是按照新生代、老年代和永久代这一经典策略划分的。然而，其他的一些堆内存划分策略也是可行的，一个突出的例子就是新的 G1 垃圾回收器，它模糊了新生代和老年代之间的区别。此外，目前的开发进程似乎表明在未来的 HotSpot JVM 版本中，将不会区分老年代和永久代。</li></ul></li></ul></li><li>-Xms and -Xmx (or: -XX:InitialHeapSize and -XX:MaxHeapSize)指定 JVM 的初始和最大堆内存大小新生代垃圾回收</li><li>-XX:NewSize and -XX:MaxNewSize新生代只是整个堆的一部分，新生代设置的越大，老年代区域就会减少</li><li>-XX:NewRatio动态分配新生代与老生代比例</li><li>-XX:SurvivorRatio 动态分配新生代的伊甸园区与幸存区（伊甸园区大于幸存区【俩个幸存区大小相同】）</li><li>-XX:+PrintTenuringDistribution</li><li>-XX:InitialTenuringThreshold， -XX:MaxTenuringThreshold and -XX:TargetSurvivorRatio</li><li>-XX:+NeverTenure and -XX:+AlwaysTenure</li></ul><h2 id="GC-日志（垃圾收集）"><a href="#GC-日志（垃圾收集）" class="headerlink" title="GC 日志（垃圾收集）"></a>GC 日志（垃圾收集）</h2><p>作用：记录了每一次的 GC 的执行时间和执行结果，通过分析 GC 日志可以优化堆设置和 GC 设置，或者改进应用程序的对象分配模式</p><ul><li><p>-XX:+PrintGC（- verbose:gc） 简单日志模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">每一次新生代（young generation）的 GC 和每一次的 Full GC 打印一行信息。</span><br><span class="line">[GC 246656K-&gt;243120K(376320K), 0.0929090 secs]</span><br><span class="line">gc类型 gc使用的前的堆空间 gc使用后的堆大小 当前堆容量 gc持续时间</span><br></pre></td></tr></table></figure></li><li><p>XX:PrintGCDetails 详细 GC 日志模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[GC[PSYoungGen: 142816K-&gt;10752K(142848K)] 246648K-&gt;243136K(375296K), 0.0935090 secs]</span><br><span class="line">[Times: user=0.55 sys=0.10, real=0.09 secs]</span><br><span class="line"></span><br><span class="line">这是一次在 young generation 中的 GC，它将已使用的堆空间从 246648K 减少到了 243136K，用时 0.0935090 秒。此外我们还可以得到更多的信息：所使用的垃圾收集器（即 PSYoungGen）、young generation 的大小和使用情况（在这个例子中 “PSYoungGen” 垃圾收集器将 young generation 所使用的堆空间从 142816K 减少到 10752K）。</span><br><span class="line">CPU 时间信息 =用户空间+系统空间</span><br><span class="line">real gc运行真实时间</span><br></pre></td></tr></table></figure></li><li><p>-XX:+PrintGCTimeStamps 和 - XX:+PrintGCDateStamps【绝对时间】将时间和日期也加到 GC 日志中</p></li><li>-Xloggc（- XX:+PrintGC - XX:+PrintGCTimeStamps）输出到指定的文件</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;jvm参数&quot;&gt;&lt;a href=&quot;#jvm参数&quot; class=&quot;headerlink&quot; title=&quot;jvm参数&quot;&gt;&lt;/a&gt;jvm参数&lt;/h1&gt;&lt;h2 id=&quot;JVM-类型以及编译器模式&quot;&gt;&lt;a href=&quot;#JVM-类型以及编译器模式&quot; class=&quot;header
      
    
    </summary>
    
      <category term="Java" scheme="https://github.com/xuegangliu/blog/categories/Java/"/>
    
    
      <category term="Java" scheme="https://github.com/xuegangliu/blog/tags/Java/"/>
    
      <category term="JVM" scheme="https://github.com/xuegangliu/blog/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>前端问题</title>
    <link href="https://github.com/xuegangliu/blog/2017/07/19/javascript/js-problem/"/>
    <id>https://github.com/xuegangliu/blog/2017/07/19/javascript/js-problem/</id>
    <published>2017-07-19T13:33:02.000Z</published>
    <updated>2017-07-13T15:33:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h1><hr><ol><li>ajax怎么解决跨域？<ul><li>1，代理（通过后台操作）</li><li>2，JSONP（添加响应头，允许跨域 ）<pre><code>addHeader(‘Access-Control-Allow-Origin:*’);//允许所有来源访问  addHeader(‘Access-Control-Allow-Method:POST,GET’);//允许访问的方式</code></pre></li><li>3，在ajax的dataType方式改为“jsonp”</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;问题记录&quot;&gt;&lt;a href=&quot;#问题记录&quot; class=&quot;headerlink&quot; title=&quot;问题记录&quot;&gt;&lt;/a&gt;问题记录&lt;/h1&gt;&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;ajax怎么解决跨域？&lt;ul&gt;
&lt;li&gt;1，代理（通过后台操作）&lt;/li&gt;
&lt;li&gt;2，JSONP（添
      
    
    </summary>
    
      <category term="javascript" scheme="https://github.com/xuegangliu/blog/categories/javascript/"/>
    
    
      <category term="javascript" scheme="https://github.com/xuegangliu/blog/tags/javascript/"/>
    
      <category term="js" scheme="https://github.com/xuegangliu/blog/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="https://github.com/xuegangliu/blog/2017/07/19/other/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://github.com/xuegangliu/blog/2017/07/19/other/设计模式/</id>
    <published>2017-07-19T13:33:02.000Z</published>
    <updated>2017-07-13T15:33:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式-Design-pattern"><a href="#设计模式-Design-pattern" class="headerlink" title="设计模式(Design pattern)"></a>设计模式(Design pattern)</h1><h2 id="设计模式简介"><a href="#设计模式简介" class="headerlink" title="设计模式简介"></a>设计模式简介</h2><ol><li><strong>设计模式(Design pattern)</strong> 代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。</li><li><strong>设计模式</strong>是软件开发人员在软件开发过程中面临的一般问题的解决方案。</li><li>这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</li><li><strong>设计模式</strong>是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。</li><li>使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 </li><li>毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。</li><li>项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。</li></ol><h2 id="设计模式原则"><a href="#设计模式原则" class="headerlink" title="设计模式原则"></a><strong>设计模式原则</strong></h2><ul><li><em>开闭原则（Open Close Principle）</em></li></ul><p>开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p><ul><li><em>里氏代换原则（Liskov Substitution Principle）</em></li></ul><p>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p><ul><li><em>依赖倒转原则（Dependence Inversion Principle）</em></li></ul><p>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p><ul><li><em>接口隔离原则（Interface Segregation Principle）</em></li></ul><p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p><ul><li><p><em>迪米特法则，又称最少知道原则（Demeter Principle）</em></p><p>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p></li><li><p><em>合成复用原则（Composite Reuse Principle）</em></p><p>合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。</p></li></ul><h2 id="设计模式的使用"><a href="#设计模式的使用" class="headerlink" title="设计模式的使用"></a>设计模式的使用</h2><ul><li>开发人员的共同平台</li></ul><p>设计模式提供了一个标准的术语系统，且具体到特定的情景。例如，单例设计模式意味着使用单个对象，这样所有熟悉单例设计模式的开发人员都能使用单个对象，并且可以通过这种方式告诉对方，程序使用的是单例模式。</p><ul><li>最佳的实践  </li></ul><p>设计模式已经经历了很长一段时间的发展，它们提供了软件开发过程中面临的一般问题的最佳解决方案。学习这些模式有助于经验不足的开发人员通过一种简单快捷的方式来学习软件设计。</p><hr><h1 id="设计模式类型"><a href="#设计模式类型" class="headerlink" title="设计模式类型"></a>设计模式类型</h1><p><strong>创建型模式</strong></p><p>这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用新的运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</p><ul><li><em>工厂模式（Factory Pattern）</em></li><li><em>抽象工厂模式（Abstract Factory Pattern）</em>  </li><li><em>单例模式（Singleton Pattern）</em> </li><li><em>建造者模式（Builder Pattern）</em> </li><li><em>原型模式（Prototype Pattern）</em></li></ul><p><strong>结构型模式</strong></p><p>这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。    </p><ul><li><em>适配器模式（Adapter Pattern）</em>  </li><li><em>桥接模式（Bridge Pattern）</em></li><li><em>过滤器模式（Filter、Criteria Pattern）</em></li><li><em>组合模式（Composite Pattern）</em></li><li><em>装饰器模式（Decorator Pattern）</em></li><li><em>外观模式（Facade Pattern）</em></li><li><em>享元模式（Flyweight Pattern）</em></li><li><em>代理模式（Proxy Pattern）</em></li></ul><p><strong>行为型模式</strong></p><p>这些设计模式特别关注对象之间的通信。    </p><ul><li><em>责任链模式（Chain of Responsibility Pattern）</em></li><li><em>命令模式（Command Pattern）</em></li><li><em>解释器模式（Interpreter Pattern）</em></li><li><em>迭代器模式（Iterator Pattern）</em></li><li><em>中介者模式（Mediator Pattern）</em></li><li><em>备忘录模式（Memento Pattern）</em></li><li><em>观察者模式（Observer Pattern）</em></li><li><em>状态模式（State Pattern）</em></li><li><em>空对象模式（Null Object Pattern）</em></li><li><em>策略模式（Strategy Pattern）</em></li><li><em>模板模式（Template Pattern）</em></li><li><em>访问者模式（Visitor Pattern）</em></li></ul><p><strong>J2EE 模式</strong></p><p>这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。    </p><ul><li><em>MVC 模式（MVC Pattern）</em></li><li><em>业务代表模式（Business Delegate Pattern）</em></li><li><em>组合实体模式（Composite Entity Pattern）</em></li><li><em>数据访问对象模式（Data Access Object Pattern）</em></li><li><em>前端控制器模式（Front Controller Pattern）</em></li><li><em>拦截过滤器模式（Intercepting Filter Pattern）</em></li><li><em>服务定位器模式（Service Locator Pattern）</em></li><li><em>传输对象模式（Transfer Object Pattern）</em></li></ul><h2 id="设计模式直接的关系"><a href="#设计模式直接的关系" class="headerlink" title="设计模式直接的关系"></a>设计模式直接的关系</h2><p><img src="/blog/images/java/design-patterns.jpg" alt="设计模式图"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;设计模式-Design-pattern&quot;&gt;&lt;a href=&quot;#设计模式-Design-pattern&quot; class=&quot;headerlink&quot; title=&quot;设计模式(Design pattern)&quot;&gt;&lt;/a&gt;设计模式(Design pattern)&lt;/h1&gt;&lt;h2
      
    
    </summary>
    
      <category term="Java" scheme="https://github.com/xuegangliu/blog/categories/Java/"/>
    
    
      <category term="Java" scheme="https://github.com/xuegangliu/blog/tags/Java/"/>
    
      <category term="设计模式" scheme="https://github.com/xuegangliu/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>docker基础</title>
    <link href="https://github.com/xuegangliu/blog/2017/01/09/system/docker%E5%9F%BA%E7%A1%80/"/>
    <id>https://github.com/xuegangliu/blog/2017/01/09/system/docker基础/</id>
    <published>2017-01-09T14:08:37.000Z</published>
    <updated>2017-01-09T14:08:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h1><ul><li>service docker start </li><li>systemctl start docker</li><li>systemctl enable docker</li></ul><h2 id="Docker-中国官方镜像加速可通过-registry-docker-cn-com"><a href="#Docker-中国官方镜像加速可通过-registry-docker-cn-com" class="headerlink" title="Docker 中国官方镜像加速可通过 registry.docker-cn.com"></a>Docker 中国官方镜像加速可通过 registry.docker-cn.com</h2><p><code>docker --registry-mirror=https://registry.docker-cn.com daemon</code></p><ul><li>为了永久性保留更改，您可以修改 /etc/docker/daemon.json 文件并添加上 registry-mirrors 键值。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">docker --registry-mirror=https://registry.docker-cn.com daemon</span><br><span class="line"></span><br><span class="line">docker run --name some-mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag</span><br></pre></td></tr></table></figure><h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><ul><li>ALTER USER ‘root‘@’%’ IDENTIFIED WITH mysql_native_password BY ‘你的密码’;<br>FLUSH PRIVILEGES;</li></ul><h2 id="mongo"><a href="#mongo" class="headerlink" title="mongo"></a>mongo</h2><ul><li>docker pull  mongo </li><li>docker run  –name some-mongo   -p 27017:27017   -d mongo   –auth     //这里的–name 放在前面并映射端口</li><li>docker    exec  -it  容器ID   /bin/bash     //进入容器</li><li>mongo  </li><li>use admin</li><li>db.createUser({user:”root”,pwd:”root”,roles:[{role:’root’,db:’admin’}]})   //创建用户,此用户创建成功,则后续操作都需要用户认证</li><li>exit  </li></ul><h2 id="ftp"><a href="#ftp" class="headerlink" title="ftp"></a>ftp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull docker.io/fauria/vsftpd</span><br><span class="line">docker run -d -v /home/vsftpd:/home/vsftpd -p 20:20 -p 21:21 -p 21100-21110:21100-21110 -e FTP_USER=test -e FTP_PASS=test --name vsftpd fauria/vsftpd</span><br></pre></td></tr></table></figure><ul><li>会以登录用户名 (test) 创建一个目录 (/home/vsftpd/test) 作为 ftp 根目录</li><li>测试时发现不加 -p 20:20 依然可以正常操作</li></ul><h2 id="sftp"><a href="#sftp" class="headerlink" title="sftp"></a>sftp</h2><ul><li>使用命令sudo docker pull luzifer/sftp-share</li><li>构建docker run -d -p 2022:22 -e USER=myuser -e PASS=myverysecretpassword luzifer/sftp-share</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;docker&quot;&gt;&lt;a href=&quot;#docker&quot; class=&quot;headerlink&quot; title=&quot;docker&quot;&gt;&lt;/a&gt;docker&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;service docker start &lt;/li&gt;
&lt;li&gt;systemctl start d
      
    
    </summary>
    
      <category term="Linux" scheme="https://github.com/xuegangliu/blog/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://github.com/xuegangliu/blog/tags/Linux/"/>
    
      <category term="Docker" scheme="https://github.com/xuegangliu/blog/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Oracle常用Sql</title>
    <link href="https://github.com/xuegangliu/blog/2016/12/04/db/Oracle%E5%B8%B8%E7%94%A8Sql/"/>
    <id>https://github.com/xuegangliu/blog/2016/12/04/db/Oracle常用Sql/</id>
    <published>2016-12-04T10:03:46.000Z</published>
    <updated>2016-12-04T10:03:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Oracle-常用SQL"><a href="#Oracle-常用SQL" class="headerlink" title="Oracle 常用SQL"></a>Oracle 常用SQL</h1><h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">--新建表：</span><br><span class="line">    create table table1( id varchar(300) primary key, name varchar(200) not null);</span><br><span class="line">--插入数据   </span><br><span class="line">    insert into table1 (id,name) values (&apos;aa&apos;,&apos;bb&apos;);</span><br><span class="line">--更新数据   </span><br><span class="line">    update table1 set id = &apos;bb&apos; where id=&apos;cc&apos;;</span><br><span class="line">--删除数据   </span><br><span class="line">    delete from table1 where id =&apos;cc&apos;;</span><br><span class="line">--删除表    </span><br><span class="line">    drop table table1;</span><br><span class="line">--修改表名： </span><br><span class="line">    alter table table1 rename to table2</span><br><span class="line">--表数据复制：</span><br><span class="line">    insert into table1 (select * from table2);</span><br><span class="line">--复制表结构： </span><br><span class="line">    create table table1 select * from table2 where 1&gt;1;</span><br><span class="line">--复制表结构和数据：</span><br><span class="line">    create table table1 select * from table2;</span><br><span class="line">--复制指定字段： </span><br><span class="line">    create table table1 as select id, name from table2 where 1&gt;1;</span><br><span class="line">--条件查询： </span><br><span class="line">    select id,name (case gender when 0 then &apos;男&apos; when 1 then ‘女’ end  ) gender from  table1</span><br></pre></td></tr></table></figure><h2 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">--绝对值：abs()</span><br><span class="line">   select abs(-2) value from dual;          --(2)</span><br><span class="line">--取整函数（大）：ceil（）</span><br><span class="line">   select ceil(-2.001) value from dual;       --(-2)</span><br><span class="line">--取整函数（小）：floor（）</span><br><span class="line">   select floor(-2.001) value from dual;       --(-3)</span><br><span class="line">--取整函数（截取）：trunc（）</span><br><span class="line">   select trunc(-2.001) value from dual;       -- (-2)</span><br><span class="line">--四舍五入：round（）</span><br><span class="line">   select round(1.234564,4) value from dual;       --(1.2346)</span><br><span class="line">--取平方：Power（m,n）</span><br><span class="line">   select power(4,2) value from dual;       --(16)</span><br><span class="line">--取平方根:SQRT()</span><br><span class="line">   select sqrt(16) value from dual;       --(4)</span><br><span class="line">--取随机数:dbms_random(minvalue,maxvalue)</span><br><span class="line">   select dbms_random.value() from dual;  (默认是0到1之间)</span><br><span class="line">　select dbms_random.value(2,4) value from dual;  （2-4之间随机数）</span><br><span class="line">--取符号：Sign()</span><br><span class="line">　　select sign(-3) value from dual; --(-1)</span><br><span class="line">　　select sign(3) value from dual; --(1)</span><br><span class="line">--取集合的最大值:greatest(value)</span><br><span class="line">   select greatest(-1,3,5,7,9) value from dual;       --(9)</span><br><span class="line">--取集合的最小值:least(value)</span><br><span class="line">   select least(-1,3,5,7,9) value from dual;       --(-1)</span><br><span class="line">--处理Null值：nvl(空值，代替值)</span><br><span class="line">   select  nvl(null,10) value from dual;       --(10)</span><br><span class="line">   select nvl(score,10) score from student;</span><br></pre></td></tr></table></figure><h2 id="rownum相关"><a href="#rownum相关" class="headerlink" title="rownum相关"></a>rownum相关</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">--rownum小于某个数时可以直接作为查询条件（注意oracle不支持select top）</span><br><span class="line">select * from student where rownum &lt;3;</span><br><span class="line">--查询rownum大于某个数值,需要使用子查询，并且rownum需要有别名</span><br><span class="line">select * from(select rownum rn ,id,name from student) where rn&gt;2;</span><br><span class="line">select * from (select rownum rn, student.* from student) where rn &gt;3;</span><br><span class="line">--区间查询</span><br><span class="line">select * from (select rownum rn, student.* from student) where rn &gt;3 and rn&lt;6;</span><br><span class="line">--排序+前n条</span><br><span class="line">select * from (select rownum rn, t.* from ( select d.* from DJDRUVER d order  by drivernumber)t )p where p.rn&lt;10;</span><br><span class="line">--排序+区间查询1</span><br><span class="line">select * from (select rownum rn, t.* from ( select d.* from DJDRIVER d order by DJDRIVER_DRIVERTIMES)t )p where p.rn&lt;9 and p.rn&gt;6;</span><br><span class="line">--排序+区间查询2</span><br><span class="line">select * from (select rownum rn, t.* from ( select d.* from DJDRIVER d order by DJDRIVER_DRIVERTIMES)t where rownum&lt;9 )p where p.rn&gt;6;--效率远高于方式一</span><br></pre></td></tr></table></figure><h2 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">--效率低</span><br><span class="line">select * from (select rownum rn, d.* from DJDRIVER d  )p where p.rn&lt;=20 and p.rn&gt;=10;</span><br><span class="line">select * from (select rownum rn, d.* from DJDRIVER d  )p where p.rn between 10 and 20;</span><br><span class="line">--效率高 </span><br><span class="line">select * from (select rownum rn, d.* from DJDRIVER d where rownum&lt;=20 )p where p.rn&gt;=10;</span><br><span class="line"></span><br><span class="line">--排序+区间查询1（效率低）</span><br><span class="line">select * from (select rownum rn, t.* from ( select d.* from DJDRIVER d order by DJDRIVER_DRIVERTIMES)t )p where p.rn&lt;=20 and p.rn&gt;=10;</span><br><span class="line">select * from (select rownum rn, t.* from ( select d.* from DJDRIVER d order by DJDRIVER_DRIVERTIMES)t )p where p.rn between 10 and 20;</span><br><span class="line">--排序+区间查询2（效率高） </span><br><span class="line">select * from (select rownum rn, t.* from ( select d.* from DJDRIVER d order by DJDRIVER_DRIVERTIMES)t where rownum&lt;=20 )p where p.rn&gt;=10;</span><br></pre></td></tr></table></figure><h2 id="时间处理"><a href="#时间处理" class="headerlink" title="时间处理"></a>时间处理</h2><p>日期<br>年 yyyy yyy yy year<br>月 month mm mon month<br>日+星期  dd ddd(一年中第几天) dy day<br>小时  hh hh24<br>分 mi<br>秒 ss<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">select to_char(sysdate,&apos;yyyy-mm-dd hh24:mi:ss&apos;)currenttime, </span><br><span class="line">       to_char(sysdate,&apos;yyyy&apos;) year,</span><br><span class="line">       to_char(sysdate,&apos;mm&apos;) month,</span><br><span class="line">       to_char(sysdate,&apos;dd&apos;) day,</span><br><span class="line">       to_char(sysdate,&apos;day&apos;) week,</span><br><span class="line">       to_char(sysdate,&apos;hh24&apos;)hour,</span><br><span class="line">       to_char(sysdate,&apos;mi&apos;) minute,</span><br><span class="line">       to_char(sysdate,&apos;ss&apos;) second</span><br><span class="line">from dual;</span><br><span class="line"></span><br><span class="line">months_between(to_date(&apos;03-31-2014&apos;,&apos;MM-DD-YYYY&apos;),to_date(&apos;12-31-2013&apos;,&apos;MM-DD-YYYY&apos;)) </span><br><span class="line"></span><br><span class="line">next_day(sysdate,6)</span><br></pre></td></tr></table></figure></p><p><a href="https://www.cnblogs.com/wishyouhappy/p/3700683.html" target="_blank" rel="noopener">oracle基本sql</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Oracle-常用SQL&quot;&gt;&lt;a href=&quot;#Oracle-常用SQL&quot; class=&quot;headerlink&quot; title=&quot;Oracle 常用SQL&quot;&gt;&lt;/a&gt;Oracle 常用SQL&lt;/h1&gt;&lt;h2 id=&quot;基本&quot;&gt;&lt;a href=&quot;#基本&quot; class=&quot;
      
    
    </summary>
    
      <category term="Oracle" scheme="https://github.com/xuegangliu/blog/categories/Oracle/"/>
    
    
      <category term="Oracle" scheme="https://github.com/xuegangliu/blog/tags/Oracle/"/>
    
      <category term="SQL" scheme="https://github.com/xuegangliu/blog/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>Oracle索引</title>
    <link href="https://github.com/xuegangliu/blog/2016/12/04/db/Oracle%E7%B4%A2%E5%BC%95/"/>
    <id>https://github.com/xuegangliu/blog/2016/12/04/db/Oracle索引/</id>
    <published>2016-12-04T10:03:46.000Z</published>
    <updated>2016-12-04T10:03:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Oracle索引"><a href="#Oracle索引" class="headerlink" title="Oracle索引"></a>Oracle索引</h1><h2 id="查询时索引类型扫描"><a href="#查询时索引类型扫描" class="headerlink" title="查询时索引类型扫描"></a>查询时索引类型扫描</h2><ul><li><p>index unique scan</p><p>  索引唯一扫描，当可以优化器发现某个查询条件可以利用到主键、唯一键、具有外键约束的列，或者只是访问其中某行索引所在的数据的时候，优化器会选择这种扫描类型。</p></li><li><p>index range scan</p><p>  索引范围扫描，当优化器发现在UNIQUE列上使用了大于、小于、大于等于、小于等于以及BETWEEN等就会使用范围扫描，在组合列上只使用部分进行查询，导致查询出多行数据。对非唯一的索引列上进行任何活动都会使用index range scan。</p></li><li><p>index full scan</p><p>  全索引扫描，如果要查询的数据可以全部从索引中获取，则使用全索引扫描。</p></li><li><p>index fast full scan</p><p>  索引快速扫描，扫描索引中的全部的数据块，与全索引扫描的方式基本上类似。两者之间的明显的区别是，索引快速扫描对查询的数据不进行排序，数据返回的时候不是排序的。“在这种存取方法中，可以使用多块读功能，也可以使用并行读入，从而得到最大的吞吐量和缩短执行时间”。</p><p>order by、group by使用索引的前提条件:</p><ul><li>1.order by、group by中所有的列必须包含在相同的索引中并保持在索引中的排列顺序;</li><li>2.order by、group by中所有的列必须定义为非空</li></ul></li></ul><h2 id="不走索引的情况"><a href="#不走索引的情况" class="headerlink" title="不走索引的情况"></a>不走索引的情况</h2><ul><li>1.where子句中使用 <code>is null</code> 和 <code>is not null</code></li><li>2.where子句中使用函数</li><li>3.使用<code>like &#39;%T&#39;</code> 进行模糊查询</li><li>4.where子句中使用不等于操作(包括：<code>&lt;&gt;, !=, not colum &gt;= ?, not colum &lt;= ?</code>,可以使用or代替)</li><li>5.比较不匹配数据类型，例如：<code>select * from tablewhere name = 1</code>name为varchar2类型字段</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Oracle索引&quot;&gt;&lt;a href=&quot;#Oracle索引&quot; class=&quot;headerlink&quot; title=&quot;Oracle索引&quot;&gt;&lt;/a&gt;Oracle索引&lt;/h1&gt;&lt;h2 id=&quot;查询时索引类型扫描&quot;&gt;&lt;a href=&quot;#查询时索引类型扫描&quot; class=&quot;he
      
    
    </summary>
    
      <category term="Oracle" scheme="https://github.com/xuegangliu/blog/categories/Oracle/"/>
    
    
      <category term="Oracle" scheme="https://github.com/xuegangliu/blog/tags/Oracle/"/>
    
      <category term="SQL" scheme="https://github.com/xuegangliu/blog/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>Maven构建</title>
    <link href="https://github.com/xuegangliu/blog/2016/11/09/tools/Maven%E6%9E%84%E5%BB%BA/"/>
    <id>https://github.com/xuegangliu/blog/2016/11/09/tools/Maven构建/</id>
    <published>2016-11-09T15:10:43.000Z</published>
    <updated>2016-11-09T15:10:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Maven构建"><a href="#Maven构建" class="headerlink" title="Maven构建"></a>Maven构建</h1><h2 id="maven生命周期"><a href="#maven生命周期" class="headerlink" title="maven生命周期"></a>maven生命周期</h2><p><a href="https://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html" target="_blank" rel="noopener">官方文档</a></p><p>基本的生命周期</p><ul><li>验证（validate） - 验证项目是否正确，所有必要的信息可用</li><li>编译（compile） - 编译项目的源代码</li><li>测试（test） - 使用合适的单元测试框架测试编译的源代码。这些测试不应该要求代码被打包或部署</li><li>打包（package） - 采用编译的代码，并以其可分配格式（如JAR）进行打包。</li><li>验证（verify） - 对集成测试的结果执行任何检查，以确保满足质量标准</li><li>安装（install） - 将软件包安装到本地存储库中，用作本地其他项目的依赖项</li><li>部署（deploy） - 在构建环境中完成，将最终的包复制到远程存储库以与其他开发人员和项目共享。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Maven构建&quot;&gt;&lt;a href=&quot;#Maven构建&quot; class=&quot;headerlink&quot; title=&quot;Maven构建&quot;&gt;&lt;/a&gt;Maven构建&lt;/h1&gt;&lt;h2 id=&quot;maven生命周期&quot;&gt;&lt;a href=&quot;#maven生命周期&quot; class=&quot;header
      
    
    </summary>
    
      <category term="tools" scheme="https://github.com/xuegangliu/blog/categories/tools/"/>
    
    
      <category term="maven" scheme="https://github.com/xuegangliu/blog/tags/maven/"/>
    
      <category term="tools" scheme="https://github.com/xuegangliu/blog/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>git基础使用</title>
    <link href="https://github.com/xuegangliu/blog/2016/11/09/tools/git%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
    <id>https://github.com/xuegangliu/blog/2016/11/09/tools/git基础使用/</id>
    <published>2016-11-09T15:10:43.000Z</published>
    <updated>2016-11-09T15:10:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="git-常用命令-含删除文件"><a href="#git-常用命令-含删除文件" class="headerlink" title="git 常用命令(含删除文件)"></a>git 常用命令(含删除文件)</h1><h2 id="Git常用操作命令收集："><a href="#Git常用操作命令收集：" class="headerlink" title="Git常用操作命令收集："></a>Git常用操作命令收集：</h2><h3 id="1-远程仓库相关命令"><a href="#1-远程仓库相关命令" class="headerlink" title="1) 远程仓库相关命令"></a>1) 远程仓库相关命令</h3><ul><li>检出仓库：$ git clone git://github.com/jquery/jquery.git</li><li>查看远程仓库：$ git remote -v</li><li>添加远程仓库：$ git remote add [name] [url]</li><li>删除远程仓库：$ git remote rm [name]</li><li>修改远程仓库：$ git remote set-url –push[name][newUrl]</li><li>拉取远程仓库：$ git pull [remoteName] [localBranchName]</li><li>推送远程仓库：$ git push [remoteName] [localBranchName]</li></ul><h3 id="2）分支-branch-操作相关命令"><a href="#2）分支-branch-操作相关命令" class="headerlink" title="2）分支(branch)操作相关命令"></a>2）分支(branch)操作相关命令</h3><ul><li>查看本地分支：$ git branch</li><li>查看远程分支：$ git branch -r</li><li>创建本地分支：$ git branch [name] —-注意新分支创建后不会自动切换为当前分支</li><li>切换分支：$ git checkout [name]</li><li>创建新分支并立即切换到新分支：$ git checkout -b [name]</li><li>删除分支：$ git branch -d [name] —- -d选项只能删除已经参与了合并的分支，对于未有合并的分支是无法删除的。如果想强制删除一个分支，可以使用-D选项</li><li>合并分支：$ git merge [name] —-将名称为[name]的分支与当前分支合并</li><li>创建远程分支(本地分支push到远程)：$ git push origin [name]</li><li>删除远程分支：$ git push origin :heads/[name]</li><li>我从master分支创建了一个issue5560分支，做了一些修改后，使用git push origin master提交，但是显示的结果却是’Everything up-to-date’，发生问题的原因是git push origin master 在没有track远程分支的本地分支中默认提交的master分支，因为master分支默认指向了origin master 分支，这里要使用git push origin issue5560：master 就可以把issue5560推送到远程的master分支了。</li><li><p>如果想把本地的某个分支test提交到远程仓库，并作为远程仓库的master分支，或者作为另外一个名叫test的分支，那么可以这么做。</p></li><li><p>$ git push origin test:master         // 提交本地test分支作为远程的master分支 //好像只写这一句，远程的github就会自动创建一个test分支</p></li><li><p>$ git push origin test:test              // 提交本地test分支作为远程的test分支</p></li><li><p>如果想删除远程的分支呢？类似于上面，如果:左边的分支为空，那么将删除:右边的远程的分支。</p></li><li><p>$ git push origin :test              // 刚提交到远程的test将被删除，但是本地还会保存的，不用担心</p></li></ul><h3 id="3）版本-tag-操作相关命令"><a href="#3）版本-tag-操作相关命令" class="headerlink" title="3）版本(tag)操作相关命令"></a>3）版本(tag)操作相关命令</h3><ul><li>查看版本：$ git tag</li><li>创建版本：$ git tag [name]</li><li>删除版本：$ git tag -d [name]</li><li>查看远程版本：$ git tag -r</li><li>创建远程版本(本地版本push到远程)：$ git push origin [name]</li><li>删除远程版本：$ git push origin :refs/tags/[name]</li></ul><h3 id="4-子模块-submodule-相关操作命令"><a href="#4-子模块-submodule-相关操作命令" class="headerlink" title="4) 子模块(submodule)相关操作命令"></a>4) 子模块(submodule)相关操作命令</h3><ul><li>添加子模块：$ git submodule add [url] [path]如：$ git submodule add git://github.com/soberh/ui-libs.git src/main/webapp/ui-libs</li><li>初始化子模块：$ git submodule init —-只在首次检出仓库时运行一次就行</li><li>更新子模块：$ git submodule update —-每次更新或切换分支后都需要运行一下</li><li>删除子模块：（分4步走哦）<ul><li>1)$ git rm –cached [path]</li><li>2) 编辑“.gitmodules”文件，将子模块的相关配置节点删除掉</li><li>3) 编辑“.git/config”文件，将子模块的相关配置节点删除掉</li><li>4) 手动删除子模块残留的目录</li><li>5）忽略一些文件、文件夹不提交在仓库根目录下创建名称为“.gitignore”的文件，写入不需要的文件夹名或文件，每个元素占一行即可，如target,bin,*.db</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;git-常用命令-含删除文件&quot;&gt;&lt;a href=&quot;#git-常用命令-含删除文件&quot; class=&quot;headerlink&quot; title=&quot;git 常用命令(含删除文件)&quot;&gt;&lt;/a&gt;git 常用命令(含删除文件)&lt;/h1&gt;&lt;h2 id=&quot;Git常用操作命令收集：&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="tools" scheme="https://github.com/xuegangliu/blog/categories/tools/"/>
    
    
      <category term="tools" scheme="https://github.com/xuegangliu/blog/tags/tools/"/>
    
      <category term="git" scheme="https://github.com/xuegangliu/blog/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>idea快捷键</title>
    <link href="https://github.com/xuegangliu/blog/2016/11/09/tools/idea%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>https://github.com/xuegangliu/blog/2016/11/09/tools/idea快捷键/</id>
    <published>2016-11-09T15:10:43.000Z</published>
    <updated>2016-11-09T15:10:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h1><h2 id="IntelliJ-Idea"><a href="#IntelliJ-Idea" class="headerlink" title="IntelliJ Idea"></a>IntelliJ Idea</h2><h3 id="实用快捷键"><a href="#实用快捷键" class="headerlink" title="实用快捷键:"></a>实用快捷键:</h3><ul><li>Ctrl+/ 或 Ctrl+Shift+/ 注释（// 或者/<em>…</em>/ ）</li><li>Ctrl+D 复制行</li><li>Ctrl+X 删除行</li><li>快速修复 alt+enter (modify/cast)</li><li>代码提示 alt+/</li><li>ctr+G 定位某一行</li><li>Shift+F6 重构-重命名</li><li>Ctrl+R 替换文本</li><li>Ctrl+F 查找文本</li><li>Ctrl+E 最近打开的文件</li><li>Ctrl+J 自动代码</li><li>组织导入 ctr+alt+O</li><li>格式化代码 ctr+alt+L</li><li>大小写转化 ctr+shift+U</li></ul><h3 id="IntelliJ-Idea-常用快捷键列表"><a href="#IntelliJ-Idea-常用快捷键列表" class="headerlink" title="IntelliJ Idea 常用快捷键列表"></a>IntelliJ Idea 常用快捷键列表</h3><ul><li>Alt+回车 导入包,自动修正</li><li>Ctrl+N   查找类</li><li>Ctrl+Shift+N 查找文件</li><li>Ctrl+Alt+L  格式化代码</li><li>Ctrl+Alt+O 优化导入的类和包</li><li>Alt+Insert 生成代码(如get,set方法,构造函数等)</li><li>Ctrl+E或者Alt+Shift+C  最近更改的代码</li><li>Ctrl+R 替换文本</li><li>Ctrl+F 查找文本</li><li>Ctrl+Shift+Space 自动补全代码</li><li>Ctrl+空格 代码提示</li><li>Ctrl+Alt+Space 类名或接口名提示</li><li>Ctrl+P 方法参数提示</li><li>Ctrl+Shift+Alt+N 查找类中的方法或变量</li><li>Alt+Shift+C 对比最近修改的代码</li><li>Shift+F6  重构-重命名</li><li>Ctrl+Shift+先上键</li><li>Ctrl+X 删除行</li><li>Ctrl+D 复制行</li><li>Ctrl+/ 或 Ctrl+Shift+/  注释（// 或者/<em>…</em>/ ）</li><li>Ctrl+J  自动代码</li><li>Ctrl+E 最近打开的文件</li><li>Ctrl+H 显示类结构图</li><li>Ctrl+Q 显示注释文档</li><li>Alt+F1 查找代码所在位置</li><li>Alt+1 快速打开或隐藏工程面板</li><li>Ctrl+Alt+ left/right 返回至上次浏览的位置</li><li>Alt+ left/right 切换代码视图</li><li>Alt+ Up/Down 在方法间快速移动定位</li><li>Ctrl+Shift+Up/Down 代码向上/下移动。</li><li>F2 或Shift+F2 高亮错误或警告快速定位</li><li>代码标签输入完成后，按Tab，生成代码。</li><li>选中文本，按Ctrl+Shift+F7 ，高亮显示所有该文本，按Esc高亮消失。</li><li>Ctrl+W 选中代码，连续按会有其他效果</li><li>选中文本，按Alt+F3 ，逐个往下查找相同文本，并高亮显示。</li><li>Ctrl+Up/Down 光标跳转到第一行或最后一行下</li><li>Ctrl+B 快速打开光标处的类或方法 </li></ul><h3 id="1-IDEA内存优化"><a href="#1-IDEA内存优化" class="headerlink" title="1. IDEA内存优化"></a>1. IDEA内存优化</h3><p>因机器本身的配置而配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">\IntelliJ IDEA 8\bin\idea.exe.vmoptions  </span><br><span class="line">-----------------------------------------  </span><br><span class="line">-Xms64m  </span><br><span class="line">-Xmx256m  </span><br><span class="line">-XX:MaxPermSize=92m  </span><br><span class="line">-ea  </span><br><span class="line">-server  </span><br><span class="line">-Dsun.awt.keepWorkingSetOnMinimize=true</span><br></pre></td></tr></table></figure></p><h3 id="2-查询快捷键"><a href="#2-查询快捷键" class="headerlink" title="2. 查询快捷键"></a>2. 查询快捷键</h3><ul><li>CTRL+N   查找类 </li><li>CTRL+SHIFT+N  查找文件 </li><li>CTRL+SHIFT+ALT+N 查找类中的方法或变量 </li><li>CIRL+B   找变量的来源 </li><li>CTRL+ALT+B  找所有的子类 </li><li>CTRL+SHIFT+B  找变量的类 </li><li>CTRL+G   定位行 </li><li>CTRL+F   在当前窗口查找文本 </li><li>CTRL+SHIFT+F  在指定窗口查找文本 </li><li>CTRL+R   在 当前窗口替换文本 </li><li>CTRL+SHIFT+R  在指定窗口替换文本 </li><li>ALT+SHIFT+C  查找修改的文件 </li><li>CTRL+E   最近打开的文件 </li><li>F3   向下查找关键字出现位置 </li><li>SHIFT+F3  向上一个关键字出现位置 </li><li>F4   查找变量来源 </li><li>CTRL+ALT+F7  选中的字符查找工程出现的地方 </li><li>CTRL+SHIFT+O  弹出显示查找内容</li></ul><h3 id="3-自动代码"><a href="#3-自动代码" class="headerlink" title="3. 自动代码"></a>3. 自动代码</h3><ul><li>ALT+回车  导入包,自动修正 </li><li>CTRL+ALT+L  格式化代码 </li><li>CTRL+ALT+I  自动缩进 </li><li>CTRL+ALT+O  优化导入的类和包 </li><li>ALT+INSERT  生成代码(如GET,SET方法,构造函数等) </li><li>CTRL+E 最近更改的代码 </li><li>CTRL+SHIFT+SPACE 自动补全代码 </li><li>CTRL+空格  代码提示 </li><li>CTRL+ALT+SPACE  类名或接口名提示 </li><li>CTRL+P   方法参数提示 </li><li>CTRL+J   自动代码 </li><li>CTRL+ALT+T  把选中的代码放在 TRY{} IF{} ELSE{} 里</li></ul><h3 id="4-复制快捷方式"><a href="#4-复制快捷方式" class="headerlink" title="4. 复制快捷方式"></a>4. 复制快捷方式</h3><ul><li>CTRL+D   复制行 </li><li>CTRL+X   剪切,删除行  </li></ul><h3 id="5-其他快捷方式"><a href="#5-其他快捷方式" class="headerlink" title="5. 其他快捷方式"></a>5. 其他快捷方式</h3><ul><li>CIRL+U   大小写切换 </li><li>CTRL+Z   倒退 </li><li>CTRL+SHIFT+Z  向前 </li><li>CTRL+ALT+F12  资源管理器打开文件夹 </li><li>ALT+F1   查找文件所在目录位置 </li><li>SHIFT+ALT+INSERT 竖编辑模式 </li><li>CTRL+/   注释//   </li><li>CTRL+SHIFT+/  注释/<em>…</em>/ </li><li>CTRL+W   选中代码，连续按会有其他效果 </li><li>CTRL+B   快速打开光标处的类或方法 </li><li>ALT+ ←/→  切换代码视图 </li><li>CTRL+ALT ←/→  返回上次编辑的位置 </li><li>ALT+ ↑/↓  在方法间快速移动定位 </li><li>SHIFT+F6  重构-重命名 </li><li>CTRL+H   显示类结构图 </li><li>CTRL+Q   显示注释文档 </li><li>ALT+1   快速打开或隐藏工程面板 </li><li>CTRL+SHIFT+UP/DOWN 代码向上/下移动。 </li><li>CTRL+UP/DOWN  光标跳转到第一行或最后一行下 </li><li>ESC   光标返回编辑框 </li><li>SHIFT+ESC  光标返回编辑框,关闭无用的窗口 </li><li>F1   帮助千万别按,很卡! </li><li>CTRL+F4   非常重要下班都用</li></ul><h2 id="Eclipse"><a href="#Eclipse" class="headerlink" title="Eclipse"></a>Eclipse</h2><ul><li>Ctrl + 2,L  补全  自己改为Alt + q</li><li>选中按F4 或 Ctrl + t   进入层次视图—–体系结构</li><li>Alt+/    内容补全</li><li>Ctrl + 1  帮助</li><li>Ctrl + d  删除当前行</li><li>Ctrl + M  最大化当前的Edit或View (再按则反之)</li><li>Ctrl + f  查找/替换</li><li>Ctrl + 点击   进入源码</li><li>Alt + Shift + r   改名</li><li>Ctrl + Shift + o   快速导包</li><li>Ctrl + Shift + r   打开源</li><li>Ctr + Shift + f   格式化代码</li><li>Ctrl + Shift + x   变大写</li><li>Ctrl + Shift + x   变小写</li><li>Ctrl + Shift + t   类查询</li><li>syso + Alt + /   输出</li><li>Alt + ←   前一个编辑的页面</li><li>Alt + →   下一个编辑的页面</li><li>Alt + 上箭头    上移</li><li>Alt + 下箭头    下移</li><li>Ctrl + /    单行注释</li><li>Ctrl + Shift + /   多行注释</li><li>Ctrl + Shift + \   取消注释</li><li>Ctrl + Shift + c   适用于各种文档的注释</li><li>Ctrl + Alt + 上箭头/下箭头   上复制/下复制</li><li>Alt + Shift + s   源操作</li><li>Alt + Shift + t   方法操作</li><li>Alt + Shift + z   语句操作</li><li>Alt + Shift + m   提取方法</li><li>Alt + Shift + L      提取本地变量</li><li>Alt + 1   packageExporer显示</li><li>Alt + 2   console显示</li><li>Alt + 3   Outline显示</li><li>小绿圆圈——&gt;方法</li><li>小绿三角——&gt;属性</li><li>带土红色 s —–&gt;静态</li><li>Alt + 4   navigator导航显示</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;开发工具&quot;&gt;&lt;a href=&quot;#开发工具&quot; class=&quot;headerlink&quot; title=&quot;开发工具&quot;&gt;&lt;/a&gt;开发工具&lt;/h1&gt;&lt;h2 id=&quot;IntelliJ-Idea&quot;&gt;&lt;a href=&quot;#IntelliJ-Idea&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="tools" scheme="https://github.com/xuegangliu/blog/categories/tools/"/>
    
    
      <category term="tools" scheme="https://github.com/xuegangliu/blog/tags/tools/"/>
    
      <category term="idea" scheme="https://github.com/xuegangliu/blog/tags/idea/"/>
    
  </entry>
  
  <entry>
    <title>公司高阶职位名称</title>
    <link href="https://github.com/xuegangliu/blog/2016/11/09/work/work-name/"/>
    <id>https://github.com/xuegangliu/blog/2016/11/09/work/work-name/</id>
    <published>2016-11-09T15:10:43.000Z</published>
    <updated>2016-11-09T15:10:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="公司高阶职位名称简介"><a href="#公司高阶职位名称简介" class="headerlink" title="公司高阶职位名称简介"></a>公司高阶职位名称简介</h1><p>CIO、CEO、CFO、COO、CTO、CKO、CPO、CGO都是属于公司的高阶职位。</p><ul><li><p>CIO（Chief Information Officer 首席信息官）</p><p>  主要负责制定公司的信息政策、标准、程序的方法，并对全公司的信息资源进行管理和控制。</p></li><li><p>CEO（Chief Executive Officer 首席执行官）</p><p>  主要负责企业日常经营管理决策。</p></li><li><p>CFO（Chief Financial Officer 首席财务官）</p><p>  全面负责企业财务管理。</p></li><li><p>COO（Chief Operating Officer 首席运营官）</p><p>  具体负责公司的日常运营。</p></li><li><p>CTO（Chief Technology Officer 首席技术官）</p><p>  企业内负责技术的最高负责人，由于互联网的迅猛发展，有时CT0和CIO是同一个人。</p></li></ul><ul><li><p>CKO（Chief Knowledge Officer 首席知识官）</p><p>  主要负责企业内部的知识管理等相关工作</p></li><li><p>CPO（Chief Procurement Officer 首席采购官）</p><p>  负责企业采购方面的全面工作。</p></li><li><p>CGO（Chief Game Officer 首席游戏官）</p><p>  这个主要是游戏公司或网吧里设置的岗位或系统，一般企业里没有这样的岗。当然，也不排除一些前卫的公司针对90后特意设置这样的岗位。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;公司高阶职位名称简介&quot;&gt;&lt;a href=&quot;#公司高阶职位名称简介&quot; class=&quot;headerlink&quot; title=&quot;公司高阶职位名称简介&quot;&gt;&lt;/a&gt;公司高阶职位名称简介&lt;/h1&gt;&lt;p&gt;CIO、CEO、CFO、COO、CTO、CKO、CPO、CGO都是属于公司的
      
    
    </summary>
    
      <category term="work" scheme="https://github.com/xuegangliu/blog/categories/work/"/>
    
    
      <category term="work" scheme="https://github.com/xuegangliu/blog/tags/work/"/>
    
  </entry>
  
  <entry>
    <title>Vim使用</title>
    <link href="https://github.com/xuegangliu/blog/2016/11/09/tools/Vim%E4%BD%BF%E7%94%A8/"/>
    <id>https://github.com/xuegangliu/blog/2016/11/09/tools/Vim使用/</id>
    <published>2016-11-09T15:10:43.000Z</published>
    <updated>2016-11-09T15:10:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vim-基本使用"><a href="#vim-基本使用" class="headerlink" title="vim 基本使用"></a>vim 基本使用</h1><p><img src="/book/images/linux/vim.gif" alt="键盘图"></p><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>刚刚启动 vi/vim，便进入了命令模式。此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。以下是常用的几个命令：</p><ul><li>i 切换到输入模式，以输入字符。</li><li>x 删除当前光标所在处的字符。</li><li>: 切换到底线命令模式，以在最底一行输入命令。</li><li>若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。</li><li>命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。</li></ul><h2 id="输入模式"><a href="#输入模式" class="headerlink" title="输入模式"></a>输入模式</h2><p>命令模式下按下i就进入了输入模式。在输入模式中，可以使用以下按键：</p><ul><li>字符按键以及Shift组合，输入字符</li><li>ENTER，回车键，换行</li><li>BACK SPACE，退格键，删除光标前一个字符</li><li>DEL，删除键，删除光标后一个字符</li><li>方向键，在文本中移动光标</li><li>HOME/END，移动光标到行首/行尾</li><li>Page Up/Page Down，上/下翻页</li><li>Insert，切换光标为输入/替换模式，光标将变成竖线/下划线</li><li>ESC，退出输入模式，切换到命令模式</li></ul><h2 id="底线命令模式"><a href="#底线命令模式" class="headerlink" title="底线命令模式"></a>底线命令模式</h2><p>在命令模式下按下:（英文冒号）就进入了底线命令模式。底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。在底线命令模式中，基本的命令有（已经省略了冒号）：</p><ul><li>q 退出程序</li><li>w 保存文件</li><li>ESC键可随时退出底线命令模式。</li></ul><p><img src="/book/images/linux/vim01.png" alt="模式切换"></p><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><h3 id="一般模式可用的光标移动、复制粘贴、搜索替换等"><a href="#一般模式可用的光标移动、复制粘贴、搜索替换等" class="headerlink" title="一般模式可用的光标移动、复制粘贴、搜索替换等"></a>一般模式可用的光标移动、复制粘贴、搜索替换等</h3><h4 id="移动光标的方法"><a href="#移动光标的方法" class="headerlink" title="移动光标的方法"></a>移动光标的方法</h4><ul><li>h 或 向左箭头键(←)    光标向左移动一个字符</li><li>j 或 向下箭头键(↓)    光标向下移动一个字符</li><li>k 或 向上箭头键(↑)    光标向上移动一个字符</li><li>l 或 向右箭头键(→)    光标向右移动一个字符</li><li>如果想要进行多次移动的话，例如向下移动 30 行，可以使用 “30j” 或 “30↓” 的组合按键， 亦即加上想要进行的次数(数字)后，按下动作即可！</li><li>[Ctrl] + [f]    屏幕『向下』移动一页，相当于 - - - [Page Down]按键 (常用)</li><li>[Ctrl] + [b]    屏幕『向上』移动一页，相当于 - - - [Page Up] 按键 (常用)</li><li>[Ctrl] + [d]    屏幕『向下』移动半页</li><li>[Ctrl] + [u]    屏幕『向上』移动半页</li><li><ul><li>光标移动到非空格符的下一行</li></ul></li><li><ul><li>光标移动到非空格符的上一行</li></ul></li><li>n<space>    那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20<space> 则光标会向后面移动 20 个字符距离。</space></space></li><li>0 或功能键[Home]    这是数字『 0 』：移动到这一行的最前面字符处 (常用)</li><li>$ 或功能键[End]    移动到这一行的最后面字符处(常用)</li><li>H    光标移动到这个屏幕的最上方那一行的第一个字符</li><li>M    光标移动到这个屏幕的中央那一行的第一个字符</li><li>L    光标移动到这个屏幕的最下方那一行的第一个字符</li><li>G    移动到这个档案的最后一行(常用)</li><li>nG    n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)</li><li>gg    移动到这个档案的第一行，相当于 1G 啊！ (常用)</li><li>n<enter>    n 为数字。光标向下移动 n 行(常用)</enter></li></ul><h4 id="搜索替换"><a href="#搜索替换" class="headerlink" title="搜索替换"></a>搜索替换</h4><ul><li>/word    向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！ (常用)</li><li>?word    向光标之上寻找一个字符串名称为 word 的字符串。</li><li>n    这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</li><li>N    这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。</li><li>使用 /word 配合 n 及 N 是非常有帮助的！可以让你重复的找到一些你搜寻的关键词！</li><li>:n1,n2s/word1/word2/g    n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则：</li><li>『:100,200s/vbird/VBIRD/g』。(常用)</li><li>:1,$s/word1/word2/g    从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)</li><li>:1,$s/word1/word2/gc    从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)</li></ul><h4 id="删除、复制与贴上"><a href="#删除、复制与贴上" class="headerlink" title="删除、复制与贴上"></a>删除、复制与贴上</h4><ul><li>x, X    在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)</li><li>nx    n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。</li><li>dd    删除游标所在的那一整行(常用)</li><li>ndd    n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行 (常用)</li><li>d1G    删除光标所在到第一行的所有数据</li><li>dG    删除光标所在到最后一行的所有数据</li><li>d$    删除游标所在处，到该行的最后一个字符</li><li>d0    那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</li><li>yy    复制游标所在的那一行(常用)</li><li>nyy    n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)</li><li>y1G    复制游标所在行到第一行的所有数据</li><li>yG    复制游标所在行到最后一行的所有数据</li><li>y0    复制光标所在的那个字符到该行行首的所有数据</li><li>y$    复制光标所在的那个字符到该行行尾的所有数据</li><li>p, P    p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用)</li><li>J    将光标所在行与下一行的数据结合成同一行</li><li>c    重复删除多个数据，例如向下删除 10 行，[ 10cj ]</li><li>u    复原前一个动作。(常用)</li><li>[Ctrl]+r    重做上一个动作。(常用)</li><li>这个 u 与 [Ctrl]+r 是很常用的指令！一个是复原，另一个则是重做一次～ 利用这两个功能按键，你的编辑，嘿嘿！很快乐的啦！</li><li>.    不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用)</li></ul><h3 id="一般模式切换到编辑模式的可用的按钮说明"><a href="#一般模式切换到编辑模式的可用的按钮说明" class="headerlink" title="一般模式切换到编辑模式的可用的按钮说明"></a>一般模式切换到编辑模式的可用的按钮说明</h3><p>进入输入或取代的编辑模式</p><ul><li>i, I    进入输入模式(Insert mode)：i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 (常用)</li><li>a, A    进入输入模式(Insert mode)：a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)</li><li>o, O    进入输入模式(Insert mode)：这是英文字母 o 的大小写。o 为『在目前光标所在的下一行处输入新的一行』； O 为在目前光标所在处的上一行输入新的一行！(常用)</li><li>r, R    进入取代模式(Replace mode)：r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)<br><code>在 vi 画面的左下角处会出现『--INSERT--』或『--REPLACE--』的字样 才能输入</code></li><li>[Esc]    退出编辑模式，回到一般模式中(常用)</li></ul><h3 id="一般模式切换到指令行模式的可用的按钮说明"><a href="#一般模式切换到指令行模式的可用的按钮说明" class="headerlink" title="一般模式切换到指令行模式的可用的按钮说明"></a>一般模式切换到指令行模式的可用的按钮说明</h3><p>指令行的储存、离开等指令</p><ul><li>:w    将编辑的数据写入硬盘档案中(常用)</li><li>:w!    若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！</li><li>:q    离开 vi (常用)</li><li>:q!    若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。<br>注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～</li><li>:wq    储存后离开，若为 :wq! 则为强制储存后离开 (常用)<br>ZZ    这是大写的 Z 喔！若档案没有更动，则不储存离开，若档案已经被更动过，则储存后离开！</li><li>:w [filename]    将编辑的数据储存成另一个档案（类似另存新档）</li><li>:r [filename]    在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面</li><li>:n1,n2 w [filename]    将 n1 到 n2 的内容储存成 filename 这个档案。</li><li>:! command    暂时离开 vi 到指令行模式下执行 command 的显示结果！例如<br>『:! ls /home』即可在 vi 当中察看 /home 底下以 ls 输出的档案信息！</li></ul><h3 id="vim-环境的变更"><a href="#vim-环境的变更" class="headerlink" title="vim 环境的变更"></a>vim 环境的变更</h3><ul><li>:set nu    显示行号，设定之后，会在每一行的前缀显示该行的行号</li><li>:set nonu    与 set nu 相反，为取消行号！</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;vim-基本使用&quot;&gt;&lt;a href=&quot;#vim-基本使用&quot; class=&quot;headerlink&quot; title=&quot;vim 基本使用&quot;&gt;&lt;/a&gt;vim 基本使用&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/book/images/linux/vim.gif&quot; alt=&quot;键盘图
      
    
    </summary>
    
      <category term="Linux" scheme="https://github.com/xuegangliu/blog/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://github.com/xuegangliu/blog/tags/Linux/"/>
    
      <category term="Vim" scheme="https://github.com/xuegangliu/blog/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>Linux工具</title>
    <link href="https://github.com/xuegangliu/blog/2016/11/09/tools/Linux%E5%B7%A5%E5%85%B7/"/>
    <id>https://github.com/xuegangliu/blog/2016/11/09/tools/Linux工具/</id>
    <published>2016-11-09T15:07:29.000Z</published>
    <updated>2016-11-09T15:07:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="程序构建"><a href="#程序构建" class="headerlink" title="程序构建"></a>程序构建</h2><h3 id="1-配置-gt-2-编译-gt-3-安装"><a href="#1-配置-gt-2-编译-gt-3-安装" class="headerlink" title="1.配置 -&gt; 2.编译 -&gt; 3.安装"></a>1.配置 -&gt; 2.编译 -&gt; 3.安装</h3><ol><li>配置做的工作主要是检查当前环境是否满足要安装软件的依赖关系，以及设置程序安装所需要的初始化信息，比如安装路径，需要安装哪些组件；配置完成，会生成makefile文件供第二步make使用；</li><li>编译是对源文件进行编译链接生成可执行程序；</li><li>安装做的工作就简单多了，就是将生成的可执行文件拷贝到配置时设置的初始路径下；</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./configure --help</span><br><span class="line">./configure --prefix=/usr/local/snmp</span><br><span class="line">make -f myMakefile</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><hr><h2 id="程序调试"><a href="#程序调试" class="headerlink" title="程序调试"></a>程序调试</h2><h3 id="gdb-程序交互调试"><a href="#gdb-程序交互调试" class="headerlink" title="gdb 程序交互调试"></a>gdb 程序交互调试</h3><hr><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">top</span><br><span class="line">free</span><br><span class="line">vmstat</span><br></pre></td></tr></table></figure><p>进入交互模式后:<br>输入M，进程列表按内存使用大小降序排序，便于我们观察最大内存使用者使用有问题（检测内存泄漏问题）;<br>输入P，进程列表按CPU使用大小降序排序，便于我们观察最耗CPU资源的使用者是否有问题；<br>top第三行显示当前系统的，其中有两个值很关键:<br>%id：空闲CPU时间百分比，如果这个值过低，表明系统CPU存在瓶颈；<br>%wa：等待I/O的CPU时间百分比，如果这个值过高，表明IO存在瓶颈；</p><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><p>如果IO存在性能瓶颈，top工具中的%wa会偏高；<br>进一步分析使用iostat工具<br>如果%iowait的值过高，表示硬盘存在I/O瓶颈。<br>如果 %util 接近 100%，说明产生的I/O请求太多，I/O系统已经满负荷，该磁盘可能存在瓶颈。<br>如果 svctm 比较接近 await，说明 I/O 几乎没有等待时间；<br>如果 await 远大于 svctm，说明I/O 队列太长，io响应太慢，则需要进行必要优化。<br>如果avgqu-sz比较大，也表示有大量io在等待。</p><h3 id="分析进程调用"><a href="#分析进程调用" class="headerlink" title="分析进程调用"></a>分析进程调用</h3><ul><li>pstack用来跟踪进程栈<blockquote><p>pstack [pid]</p></blockquote></li><li>strace用来跟踪进程中的系统调用</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;程序构建&quot;&gt;&lt;a href=&quot;#程序构建&quot; class=&quot;headerlink&quot; title=&quot;程序构建&quot;&gt;&lt;/a&gt;程序构建&lt;/h2&gt;&lt;h3 id=&quot;1-配置-gt-2-编译-gt-3-安装&quot;&gt;&lt;a href=&quot;#1-配置-gt-2-编译-gt-3-安装&quot; cla
      
    
    </summary>
    
      <category term="Linux" scheme="https://github.com/xuegangliu/blog/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://github.com/xuegangliu/blog/tags/Linux/"/>
    
      <category term="Tools" scheme="https://github.com/xuegangliu/blog/tags/Tools/"/>
    
  </entry>
  
</feed>
